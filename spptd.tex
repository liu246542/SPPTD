\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage[OT1]{fontenc}
\usepackage{xcolor}
\usepackage{multirow,makecell,booktabs}
\usepackage{adjustbox,threeparttable}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
% \usepackage[colorlinks]{hyperref}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Privacy-Preserving Truth Discovery for Sparse Data in Mobile Crowdsensing Systems\\
% \title{Privacy-preserving truth discovery in sparse mobile crowd sensing systems\\
% {\footnotesize \textsuperscript{*}Note: Sub-titles are not captured in Xplore and
% should not be used}
% \thanks{Identify applicable funding agency here. If none, delete this.}
}

\author{\IEEEauthorblockN{xxx}
\IEEEauthorblockA{\textit{University of Science and Technology of China}\\
Hefei, Anhui 230027, China \\
xxx@mail.ustc.edu.cn}
}
\maketitle

\begin{abstract}
Truth discovery is an effective method to infer the truthful information among a large amount of sensory data in mobile crowdsensing systems.
Privacy-preserving truth discovery schemes require the cloud servers should not access each participant's sensory data directly when executing truth discovery.
In real practice, it is common that the sensory data collected by some participants are sparse, which implies that the privacy of whether a participant collects a specific data also need to be protected.
However, existing privacy-preserving truth discovery schemes do not consider sparse data scenarios in crowdsensing systems.
In this paper, we address the privacy issues in truth discovery when sensory data are sparse.
By employing additively homomorphic cryptosystem with two non-colluding servers, we design an efficient privacy-preserving truth discovery scheme to guarantee strong privacy even in sparse data scenarios.
Moreover, the security analysis and performance evaluation show that our proposed scheme can satisfy the security and privacy-preserving requirements with both low computation and communication overheads.
\end{abstract}

\begin{IEEEkeywords}
Truth Discovery, Privacy Preservation, Sparse Data, Mobile Crowdsensing
\end{IEEEkeywords}

\section{Introduction}~\label{sec1}
Over the past few years, developments in the field of cloud computing and Internet of Things have led to a growing interest in mobile crowdsensing systems.
In a typical mobile crowdsensing system, the cloud server can collect and analyze the sensory data from different mobile devices (e.g., smartphones, wearables and on-board computers, usually referred to {\em workers}).
 % sensory data are collected by different mobile devices (e.g., smartphones, wearables) with a highly dynamic nature.
% Benefiting from crowd sensing, a cloud server can collect and analyze the sensory data from different terminal devices (usually called sensing workers).
However, the quality of sensory data provided by different workers may vary greatly, it is difficult for cloud servers to derive reliable aggregated result.
To address this challenge, a series of methods called truth discovery~\cite{li_resolving_2014,li_confidence-aware_2014,li_conflicts_2016} have been proposed, where the general principle is to estimate each worker's reliability degree (usually referred to {\em weight}) before calculating the truthful result (usually referred to {\em ground truth}).

Though truth discovery can help cloud server to derive ground truth in an effective way, it poses threats to workers' privacy directly.
To achieve privacy preservation, a considerable amount of work has been proposed using different alternatives\cite{miao_cloud-enabled_2015,miao_lightweight_2017,xu_efficient_2019,zhang_reliable_2019,xue_inpptd_2020}.
% 大多数 基于 CRH， 默认 所有终端 观测 所有对象数据，引出我们的 contribution
Most of these approaches are based on CRH algorithm~\cite{li_resolving_2014}, which is a representative algorithm of truth discovery in recent years.
The core principle of CRH is that a worker will be assigned a higher weight if the corresponding sensory data are closer to the ground truths, and the sensory data provided by a worker will be counted more if this worker has a higher weight~\cite{xu_efficient_2019}.
Since the CRH algorithm requires that each worker has to provide data over all sensed objects, it will face challenge when a worker only provides data over partial sensed objects for some reasons.
% It seems impractical in real mobile sensing systems because 
Taking the sparse mobile crowd sensing~\cite{wang_sparse_2016} as an example, the sensed objects represent different sub-areas.
To collect sensory for all sensed objects, workers need to access into distinct sub-areas within a specific period, which is impractical.
% which infers the sensory values provided by workers are sparse.
In this scenario, the sensory data provided by workers are usually sparse.
So, it is infeasible to apply recent CRH-based privacy-preserving truth discovery schemes in this situation.

% contribution
In this paper, we address the privacy issues in sparse data for truth discovery, and propose a privacy-preserving truth discovery scheme to deal with the issues.
In particular, our contributions are summarized in the following:
\begin{itemize}
  \item We identify the privacy requirements in the situation of data sparsity for truth discovery, and design a novel privacy-preserving truth discovery scheme based on CATD algorithm.
  % present a novel privacy-preserving truth discovery schemes which 
   % resolve the issues of data sparsity based on the CATD algorithm rather than .
  \item By employing additively homomorphic cryptosystem with two non-colluding
servers, our proposed scheme provides strong privacy for workers in an efficient way where workers do not need to participate the iteration procedure.
  \item We conduct extensive experiments to evaluate the performance of the proposed scheme, and the results demonstrate that our design is practical in real mobile crowdsensing systems.
\end{itemize}

The remainder of this paper is organized as follows.
Section~\ref{sec2} introduces the related work.
The system model and design goals are given in Section~\ref{sec3}.
In Section~\ref{sec4}, we describe the truth discovery algorithm and additively homomorphic cryptosystem.
Section~\ref{sec5} illustrates our proposed scheme in detail.
After that, security analysis and performance evaluation are provided in Section~\ref{sec6} and Section~\ref{sec7} respectively.
Finally, Section~\ref{sec8} concludes this paper.

\section{Related Work}~\label{sec2}
% 基于 CRH
% 基于 CATD
% 为什么它们都不行
Recent studies have attempted to employ cryptographic tools and data perturbation techniques to assure privacy preservation for truth discovery.
Generally, these schemes can be divided into single server setting and two non-colluding servers setting.

% At the early stage of the study, the single cloud server setting was widely adopted in privacy-preserving truth discovery.
% The single server setting is a common architecture in mobile crowdsensing
For the single server setting, ...({\em rewrite})
The first serious discussions of privacy preservation for truth discovery was presented by Miao et al.~\cite{miao_cloud-enabled_2015}.
They utilized threshold paillier cryptosystem~\cite{damgard_generalisation_2001} to encrypt the sensory data so that the works' privacy can be preserved.
But the computation overhead of threshold homomorphic cryptography is huge.
To reduce the computation overhead, Xu et al.~\cite{xu_efficient_2019} proposed an efficient scheme based on a fault-tolerance perturbation-based protocol called double-masking.
Benefit from the properties of double-masking, workers can drop out at any time point.
% their proposed mechanism is robust to workers dropping out at any time point.
However, while under the single server setting, workers have to participate the iterations, so that workers need to suffer additional computing and communication overhead.

To reduce workers' overhead, Miao et al.~\cite{miao_lightweight_2017} proposed $L$-PPTD and $L^2$-PPTD by involving two non-colluding servers.
% Different from the single cloud server setting, workers 
After that, more and more schemes are designed under two non-colluding cloud servers setting (such as~\cite{zhang_lptd_2019,zhang_reliable_2019,xue_inpptd_2020,tang_achieving_2021}).

On the other hand, most of the existing privacy-preserving truth discovery schemes are based on CRH algorithm, which requires workers to provide sensory data for all objects.
But in the real-world mobile crowdsensing systems (like sparse mobile crowd sensing~\cite{wang_sparse_2016}), it is usually impractical for workers to observe all objects at a specific moment.
The issue of data sparsity in mobile crowdsensing is getting more and more attention from recent years, especially when taking privacy preservation into account.
% According to research~\cite{wang_sparse_2020}, it is important not only to protect the sensory data observed by workers, but also to protect what objects observed by workers.
% There are two types of privacy need to protect, one is the data observed by workers, the other is which objects observed by workers.
Fortunately, there is another truth discovery algorithm called CATD~\cite{li_confidence-aware_2014} for handling long-tail data, which is also suitable for the sparse data situation.
% In comparison, CATD~\cite{li_confidence-aware_2014} is another truth discovery algorithm for handling long-tail data, which is also suitable for the sparse data situation.
Zheng et al.~\cite{zheng_learning_2018} designed an encrypted truth discovery based on CATD under two non-colluding cloud servers where all procedures are conducted in the encrypted domain.
However, according to research~\cite{wang_sparse_2020}, it is important not only to protect the sensory data observed by workers, but also to protect what objects observed by workers.
% As depicted in Figure xxx, 
% And the existing privacy-preserving scheme based on CATD~\cite{zheng_learning_2018} 
% But the existing privacy-preserving scheme based on CATD~\cite{zheng_learning_2018} only considered the privacy of sensory data 
To the best of our knowledge, there still lacks research on the two types of privayc for truth discovery in such scenarios.

\section{System Model and Design Goals}\label{sec3}
In this section, we present the system model and formulate the problem we target in this paper.
% sparse data problem in MCS.
\subsection{System Model}\label{sec3-A}
Generally, our system model consists of two types of entities: a number of workers and two cloud servers. %用图说明
The specific explanations of these entities are listed as follows.
% worker 的作用， cloud server 的作用
\begin{itemize}
  \item \textbf{Workers:} Workers refers to the data providers with mobile devices (e.g., smartphones, wearables) in MCS. They are responsible for collecting sensory data of different objects. After that, these sensory data are uploaded to two cloud servers.  Since most of mobile devices are resource-limited, it is not necessary for each worker to collect sensory data of all objects.
  \item \textbf{Clouds:} Clouds are responsible for analysing the sensory data of different objects. More specifically, after receiving the uploaded sensory data, these two cloud servers start to estimate the ground truth for each sensory object. We assume that the two cloud servers have sufficient computation and storage capabilities.
  % the agency to analyse the 
\end{itemize}
% Workers are responsible for collecting sensory data of different objects.
% After that, workers need to upload their sensory data to two cloud servers.
In this paper, suppose that there are $M$ objects need to be collected, and the number of workers is $K$.
We denote $x_m^k$ as the sensory data of object $m$ of worker $k$.
Moreover, worker $k$ also maintains an indication vector $\Phi_k = \{\phi_1^k, \ldots, \phi_M^k\}$ to mark the missing sensory objects in which $\phi_m^k = 1$ means worker $k$ has collected the sensory data of object $m$, and $\phi_m^k = 0$ otherwise.
Each worker uploads the sensory data and task vector to clouds.
After that, two cloud servers calculate each worker's weight (denoted by $w_k$ for worker $k$), and finally estimate the ground truth for each object (denoted by $x_m^*$ for object $m$). 
% The goal of two cloud servers is to estimate the ground truth $X^* = \{x_1^*, x_2^*, \ldots, x_M^*\}$ for each sensory object, where $x_m^*$ represents the estimated ground truth for $m$-th object.
\subsection{Threat Model and Design Goals}

In our proposed scheme, we assume that all entities are semi-honest, which means that no matter workers or coulds will honestly execute the protocols, but they are also curious about participants' privacy, such as workers' sensory data, worker's weights.
Moreover, the two cloud servers in our scheme are non-colluding, which is a common assumption in most two-server models~\cite{zhang_lptd_2019,zhang_reliable_2019}.
% 不考虑 恶意 workers， 不考虑 lazy workers
Note that the lazy workers are not considered, since this issue can be solved by integrating incentive mechanism~\cite{xue_inpptd_2020}.
% The consideration of malicious workers are also not involved, 
% \section{Problem Statement}
% In this section, we describe the truth discovery and formulate the sparse data problem in crowd sensing systems.

The main purpose of our shceme is to protect workers' privacy.
Since the sensory data providered by workers are sparse, we should not only consider the privacy of sensory data, but also consider the privacy of indication vectors.

\section{Preliminaries}\label{sec4}
In this section, we introduce the truth discovery algorithm CATD~\cite{li_confidence-aware_2014} and additively homomorphic cryptosystem.
% ABY2.0~\cite{patra_aby20_2020}.

\subsection{CATD}
% CATD 强调与 worker 提交的数量，。。。
In general, truth discovery algorithm consists of two parts: weight update and truth update.

\textit{1) Weight Update:} Given the ground truth, the weight for each worker $k$ is computed as
\begin{equation}
w_k = \frac{\chi^2_{(1-\alpha/2,\sum_{m=1}^M \phi_m^k)}}{\sum_{m=1}^M \phi_m^k(x_m^k - x_m^*)^2}
\end{equation}
Note that $\chi^2$ denotes the Chi-squared distribution, and the constant $\alpha$ denotes the significant level which is usually a small number such as 0.05.

\textit{2) Truth Update:} Given the weight $w_k$ for each worker $k$, the truth for each object $m$ is computed as
\begin{equation}
x_m^* = \frac{\sum_{k=1}^K w_k x_m^k}{\sum_{k=1}^K \phi_m^k w_k }
\end{equation}

In real applications, to achieve more accurate ground truth values, weight update and truth update should be executed iteratively until the convergence criteria is met.

\subsection{Additively Homomorphic Cryptosystem}\label{sec4-b}

We adopt additive homomorphic cryptosystem in our proposed scheme.
Generally, an additive homomorphic cryptosystem consists of the following probabilistic poly-time algorithms.

\begin{itemize}
  \item $\mathsf{Setup}(1^\kappa)\to pp$: Taken the input of security parameter $\kappa$, the algorithm returns the public parameter $pp$.
  \item $\mathsf{KeyGen}(1^\kappa)\to (pk, sk)$: Taken the input of security parameter $\kappa$, the algorithm returns the public key $pk$ and private key $sk$.
  \item $\mathsf{Enc}_{pk}(m)\to c$: Given the message $m$, the encryption algorithm outputs $c$ which is the ciphertext of message $m$.
  \item $\mathsf{Dec}_{sk}(c)\to m$: Given the ciphertext $c$, the decryption algorithm outputs the corresponding plaintext $m$.
\end{itemize}

We called that above public-key cryptosystem is additively homomorphic if it satisfies the following properties.

\begin{itemize}
  \item Given two ciphertexts $c_1 = \mathsf{Enc}_{pk}(m_1)$ and $c_2 = \mathsf{Enc}_{pk}(m_2)$, it holds that $\mathsf{Dec}_{sk}(c_1 \cdot c_2) = m_1 + m_2$.
  \item Given a constant $a$ and a ciphertext $c=\mathsf{Enc}_{pk}(m)$, it holds that $\mathsf{Dec}_{sk}(c^a) = a\cdot m$.
\end{itemize}

\iffalse
\subsection{ABY2.0}

% for secure two-party computation,
ABY2.0 is an efficient mixed-protocol framework which allows two parties to jointly evaluate a function based on their private inputs~\cite{patra_aby20_2020}.
In this paper, we make use of arithmetic sharing and multiplication protocol of ABY2.0 as the building blocks.
Specificly, we use $\{S_0, S_1\}$ to denote the two parties, and all protocols are executed over an $\ell$-bit ring denoted by $\mathbb{Z}_{2^\ell}$.
For a value $v\in\mathbb{Z}_{2^\ell}$, there are two sharing semantics in ABY2.0, as denoted by $[\cdot]$-sharing and $\langle \cdot \rangle$-sharing as follows.

\textit{$[\cdot]$-sharing:} A value $v\in\mathbb{Z}_{2^\ell}$ is said to be $[\cdot]$-sharing among $\{S_0, S_1\}$, which means the party $S_i$ for $i\in\{0,1\}$ holds $[v]_i$ such that $v = [v]_0 + [v]_1$.

\textit{$\langle \cdot \rangle$-sharing:} A value $v\in\mathbb{Z}_{2^\ell}$ is said to be $\langle \cdot \rangle$-sharing among $\{S_0, S_1\}$, which means the party $S_i$ for $i\in\{0,1\}$ holds $\langle v \rangle_i = (\Delta_v, [\delta_v]_i)$, where $\Delta_v = v + \delta_v$.

It is clear that both $[\cdot]$-sharing and $\langle \cdot \rangle$-sharing supoort linear operations.
For example, given the $\langle \cdot \rangle$-sharing of $a,b$ and public constants $c_1,c_2$, $S_i$ can locally compute $\langle y_i \rangle = c_1 \cdot \langle a \rangle_i + c_2 \cdot \langle b \rangle_i$.
But the multiplication protocol is non-trivial, we give a brief describtion at a high level.
For more detail, please refer to~\cite{patra_aby20_2020}.

The multiplication protocol enables two parties to generate $\langle y \rangle$ where $y = ab$ when given the $\langle \cdot \rangle$-sharing of $a,b$.
\fi

% Specifically, we 

\section{The Proposed Scheme}\label{sec5}

In this section, we describe the proposed scheme in detail.

\subsection{Overview}

% 设计目标场景
As we mentioned above, our privacy-preserving truth discovery scheme is designed for scenarios where the sensory data provided by workers are sparse.
In the proposed scheme, workers need to upload indication vectors to mark which objects they observed.
Therefore, it is a challenge to protect the privacy of indication vectors, sensory data and workers' weight at the same time.
Although applying GC is a straightforward method to achieve strong privacy preservation, the generation of GC is still a cumbersome task.
% 包含

To protect workers' privacy and make the procedure efficient, we design a novel protocol by adopting additively homomorphic cryptosystem.
The whole procedure can be divided into three phases: {\em Initialization Phase}, {\em Upload Phase}, {\em Secure Weight Update Phase} and {\em Secure Truth Update Phase}.
% At a high level, 

\subsection{Initialization Phase}

As described in Section~\ref{sec3-A}, assume that there are $K$ participating workers and $M$ sensing objects in the system.
In this phase, $S_0$ first generates an asymmetric key pair $(pk, sk)$ of the additively homomorphic cryptosystem by invoking $\mathsf{KeyGen}(\cdot)$ in Section~\ref{sec4-b}.
Then $S_0$ sets a small number for the significant level $\alpha$ ($\alpha$ is set to 0.05 by default), and publishes the public key $pk$ and significant level $\alpha$.

% the public key $pk$ and private $sk$ by invoking $\mathsf{KeyGen}(\cdot)$ described in Section~\ref{sec4-b}.

\subsection{Upload Phase}

In this phase, each worker collects sensory data for distinct objects.
Taking worker $k$ as an example, after obtaining a set of sensory data $\{x_m^k\}_{m=1}^M$ and an indication vector $\{\phi_m^k\}_{m=1}^M$, worker $k$ computes $y_k = \chi^2_{(1-\alpha/2, \sum_{m=1}^M \phi_m^k)}$.
Then for each object $m$, worker $k$ computes $\tilde{\phi}_m^k = \phi_m^k / y_k$.
Finally, worker $k$ computes additive shares ({\em need to clarify}) of $x_m^k$, $\phi_m^k$ and $\tilde{\phi}_m^k$ respectively, i.e., $x_m^k = x_{m,0}^k + x_{m,1}^k$, $\phi_m^k = \phi_{m,0}^k + \phi_{m,1}^k$, $\tilde{\phi}_m^k = \tilde{\phi}_{m,0}^k + \tilde{\phi}_{m,1}^k$, and uploads $\{x_{m,0}^k, \phi_{m,0}^k ,\tilde{\phi}_{m,0}^k\}_{m=1}^M$ to $S_0$, uploads $\{x_{m,1}^k, \phi_{m,1}^k, \tilde{\phi}_{m,1}^k\}_{m=1}^M$ to $S_1$.
When the upload process is complete, worker $k$ can go offline.
% 有的 worker 不想做全部的任务 （放到 introduction 部分）
% After that, each worker obtains a set of sensory data and an indication vector

\subsection{Secure Weight Update Phase}

In this phase, each worker's weight is estimated based on the ground truth and uploaded data.
Note that if this phase is executed for the first time, we choose the ground truth randomly.
For worker $k$, $S_0$ first computes $C_0^k$ as: 
\begin{equation}
  \begin{split}
  C_0^k = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_{m,0}^k \left(x_{m,0}^k\right)^2\right]
  \end{split}
\end{equation}
Then $S_0$ encrypts $\{x_{m,0}^k, (x_{m,0}^k)^2, \tilde{\phi}_{m,0}^k,\tilde{\phi}_{m,0}^k\cdot x_{m,0}^k\}_{m,k=1}^{M,K}$ respectively.
These ciphertexts are typically denoted by $C_{pack1}$.
Finally, $S_0$ sends $\{C_0^k\}_{k=1}^K$ and $C_{pack1}$ to $S_1$.
% We denote $C_{pack}$ as the set of ciphertexts.
% To give a clear illustration, we denote $C_{pack} = \{\mathsf{E}_{pk}(x_{m,0}^k), \mathsf{E}_{pk}((x_{m,0}^k)^2), \mathsf{E}_{pk}(\tilde{\phi}_{m,0}^k), \mathsf{E}_{pk}(\tilde{\phi}_{m,0}^k x_{m,0}^k)\}_{m=1}^M$.
 % $$\{\mathsf{E}_{pk}(x_{m,0}^k), \mathsf{E}_{pk}((x_{m,0}^k)^2), \mathsf{E}_{pk}(\tilde{\phi}_{m,0}^k), \mathsf{E}_{pk}(\tilde{\phi}_{m,0}^k x_{m,0}^k)\}_{m=1}^M$$ to $S_1$.

Upon receiving the ciphertexts, $S_1$ computes $C_1^k$,$C_2^k$,$C_3^k$,$C_4^k$ as follows.
\begin{equation}
  \begin{split}
  C_1^k & = \prod_{m=1}^M\left[ \mathsf{Enc}_{pk}{\left[\left(x_{m,0}^k\right)^2\right]}^{\tilde{\phi}_{m,1}^k} \right] \\
  & = \mathsf{Enc}_{pk}\left[ \sum_{m=1}^M \tilde{\phi}_{m,1}^k \left(x_{m,0}^k\right)^2\right]
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
  C_2^k & =  \prod_{m=1}^M\left[ \left[\mathsf{Enc}_{pk}\left(x_{m,0}^k\right)\right]^{2\left(x_{m,1}^k - x_m^*\right)\tilde{\phi}_{m,1}^k}\right] \cdot \\
          & \qquad \prod_{m=1}^M\left[ \left[\mathsf{Enc}_{pk}\left(\tilde{\phi}_{m,0}^k x_{m,0}^k\right)\right]^{2\left(x_{m,1}^k - x_m^*\right)} \right] \\
          % = & \mathsf{Enc}_{pk}\left[\sum_{m=1}^M 2(x_{m,1}^k - x_m^*)(\tilde{\phi}_{m,1}^k x_{m,0}^k +   \tilde{\phi}_{m,0}x_{m,0}^k)\right]  \\
          & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M 2\tilde{\phi}_m^k x_{m,0}^k\left(x_{m,1}^k - x_m^*\right)\right]  \\
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    C_3^k & = \prod_{m=1}^M\left[ \mathsf{Enc}_{pk}\left(\tilde{\phi}_{m,0}^k\right)^{\left(x_{m,1}^k - x_m^*\right)^2} \right] \\
    & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_{m,0}^k\left(x_{m,1}^k - x_m^*\right)^2\right] \\
    % & = \mathsf{Enc}_{pk}(\sum_{m=1}^M \tilde{\phi}_{m,0}^k \cdot (x_{m,1}^k - x_m^*)^2)
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    C_4^k & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_{m,1}^k \left(x_{m,1}^k - x_m^*\right)^2\right]
  \end{split}
\end{equation}
Then $S_1$ chooses a random value $b_k$ and computes the ciphertexts $C_k$ as 
\begin{equation}
  \begin{split}
    C_k = & \left(C_0^k\cdot C_1^k\cdot C_2^k\cdot C_3^k \cdot C_4^k\right)^{b_k} \\
        % = & \mathsf{Enc}_{pk}\left[b_k\cdot \sum_{m=1}^M \tilde{\phi}_m^k\left(\left(x_{m,0}^k\right)^2 + 2x_{m,0}^k\left(x_{m,1}^k-x_m^*\right) + \left(x_{m,1}^k - x_m^*\right)^2\right)\right]
  \end{split}
\end{equation}
Finally $S_1$ sends $\{C_k\}_{k=1}^K$ to $S_0$.
After receiving $\{C_k\}_{k=1}^K$, $S_0$ first decryptes $C_k$ with its private key and obtains the perturbed weight $\tilde{w}_k$ of worker $k$ as follows,
\begin{equation}
  \begin{split}
    \tilde{w}_k = \frac{1}{\mathsf{Dec}_{sk}\left(C_k\right)} = \frac{w_k}{b_k}
    % \tilde{w}_k = \frac{1}{\mathsf{Dec}_{sk}\left(C_k\right)} = \frac{y_k}{b_k \sum_{m=1}^M \phi_m^k\left(x_m^k - x_m^*\right)^2} = \frac{w_k}{b_k}
  ~\label{eq9}
  \end{split}
\end{equation}
Here we give the correctness analysis of Eq.~\ref{eq9}.
According to the properties of additively homomorphic cryptosystem, we have
\begin{equation}
  \begin{split}
  C_0^k C_1^k & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_{m,0}^k\left(x_{m,0}^k\right)^2 + \tilde{\phi}_{m,1}^k\left(x_{m,0}^k\right)^2  \right] \\
   & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_m^k\left(x_{m,0}^k\right)^2 \right] \\
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
  C_3^kC_4^k & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \left(\tilde{\phi}_{m,0}^k + \tilde{\phi}_{m,1}^k\right) \left(x_{m,1}^k-x_m^*\right)^2 \right] \\
  & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_m^k\left(x_{m,1}^k - x_m^*\right)^2\right] \\
  \end{split}
\end{equation}
Since $\tilde{\phi}_m^k (x_{m,0}^k)^2 + 2\tilde{\phi}_m^kx_{m,0}^k\left(x_{m,1}^k - x_m^*\right) + \tilde{\phi}_m^k(x_{m,1}^k - x_m^*)^2 = \tilde{\phi}_m^k (x_{m,0}^k + x_{m,1}^k - x_m^*)^2$, then we can further obtain
\begin{equation}
  \begin{split}
  C_k & = \left(C_0^k \cdot C_1^k\cdot C_2^k \cdot C_3^k \cdot C_4^k\right)^{b_k} \\
   & = \left[\mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_m^k (x_{m,0} + x_{m,1} - x_m^*)^2 \right]\right]^{b_k} \\
  & = \mathsf{Enc}_{pk}\left[b_k \sum_{m=1}^M \tilde{\phi}_m^k (x_m - x_m^*)^2 \right] \\
  \end{split}
\end{equation}
Hence, the perturbed weight $\tilde{w}_k$ can be written as
\begin{equation}
  \begin{split}
  \tilde{w}_k & = \frac{1}{\mathsf{Dec}_{sk}\left(C_k\right)} \\
  & = \frac{1}{b_k \sum_{m=1}^M \tilde{\phi}_m^k (x_m - x_m^*)^2} \\
  & = \frac{1}{b_k} \cdot \frac{y_k}{\sum_{m=1}^M \phi_m^k (x_m - x_m^*)^2} \\
  & = \frac{w_k}{b_k} \\
  \end{split}
\end{equation}
Therefore, the correctness of Eq.~\ref{eq9} holds.

% \begin{equation}
  % \begin{split}
    % \mathsf{Enc}_{pk}(1/w_k) & = C_0 \cdot C_1 \cdot C_2 \cdot C_3 \cdot C_4 \\
    % & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_m^k\cdot (x_{m,0}^k)^2 + 2\cdot\tilde{\phi}_m^k x_{m,0}^k (x_{m,1}^k-x_m^*) + \tilde{\phi}_m^k (x_{m,1}^k - x_m^*)^2 \right] \\
    % & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_m^k (x_m^k - x_m^*)^2 \right] \\
    % & = \mathsf{Enc}_{pk}\left[\frac{\sum_{m=1}^M \phi_m^k (x_m^k - x_m^*)^2}{y} \right] \\
  % \end{split}
% \end{equation}

\subsection{Secure Truth Update Phase}

In the weight update phase, $S_0$ obtains the perturbed weight $\tilde{w}_k$ for each worker $k$.
To estimate the ground truth for each object, $S_0$ first encrypts $\{\tilde{w}_k, \tilde{w}_k\cdot x_{m,0}^k, \tilde{w}_k\cdot \phi_{m,0}^k\}_{m,k=1}^{M,K}$.
We denote the set of ciphertexts as $C_{pack2}$.
Finally $S_0$ sends $C_{pack2}$ to $S_1$.

After receiving the ciphertexts, $S_1$ computes $C_5^m$ and $C_6^m$ as follows,
\begin{equation}
  \begin{split}
    C_5^m & = \prod_{k=1}^K\left[\left[\mathsf{Enc}_{pk}\left(\tilde{w}_k\cdot x_{m,0}^k\right)\cdot \left[\mathsf{Enc}_{pk}\left(\tilde{w}_k\right)\right]^{x_{m,1}^k}\right]^{b_k} \right] \\
     % = & \prod_{k=1}^K\left[ \right] \\
    & = \mathsf{Enc}_{pk}\left[\sum_{k=1}^K b_k \tilde{w_k}x_m^k\right]\\
    & = \mathsf{Enc}_{pk}\left[\sum_{k=1}^K w_kx_m^k\right] \\
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    C_6^m & = \prod_{k=1}^K \left[ \left[ \mathsf{Enc}_{pk}(\tilde{w}_k\cdot \phi_{m,0}^k) \cdot \left[\mathsf{Enc}_{pk}(\tilde{w}_k)\right]^{\phi_{m,1}^k}\right]^{b_k} \right] \\
     & = \mathsf{Enc}_{pk}\left[\sum_{k=1}^K b_k \tilde{w}_k\phi_m^k \right] \\
     & = \mathsf{Enc}_{pk}\left[\sum_{k=1}^K w_k\phi_m^k \right] \\
    % C_6^m = \prod_{k=1}^K \left[ \letf[\mathsf{Enc}_{pk}(\tilde{w}_k\cdot \phi_{m,0}^k)\right]^{b_k} \cdot \mathsf{Enc}_{pk}()\right]
  \end{split}
\end{equation}
% Then $S_0$ encrypts $\{\tilde{w}_k\}_{k=1}^K$, we denotes the set of ciphertexts by $C_{pack2}^k$.
% Finally $S_0$ sends $\{C_5^m, C_6^m\}_{m=1}^M$ and $\{C_{pack2}^k\}_{k=1}^K$ to $S_1$.
% After receiving the ciphertexts, $S_1$ computes $C_7^m$ and $C_8^m$ as follows,
% \begin{equation}
  % \begin{split}
    % C_7^m = \mathsf{Enc}_{pk}(\tilde{w}_k)
  % \end{split}
% \end{equation}
Finally $S_1$ sends $\{C_5^m\}_{m=1}^M$ and $\{C_6^m\}_{m=1}^M$ to $S_0$.
Then $S_0$ decrypts these ciphertexts and obtains the groud truth as follows,
\begin{equation}
  \begin{split}
    x_m^* = \frac{\mathsf{Dec}_{sk}(C_5^m)}{\mathsf{Dec}_{sk}(C_6^m)} = \frac{\sum_{k=1}^K w_kx_m^k}{\sum_{k=1}^K w_k\phi_m^k}
  \end{split}
\end{equation}

{\em (conclude this section)}

\section{System Analysis}\label{sec6}
\subsection{Security Analysis}

\iffalse
\begin{table*}[t]
    \centering
    \caption{Communication Overhead}
    \linespread{1.3}\selectfont
    \begin{tabular}{l c c c c c c}
        \hline
        \hline
        \multirow{2}*{Scheme} &  \multicolumn{2}{c}{System Initialization} & \multicolumn{3}{c}{Key Generation and Distribution}& Encryption/Decryption\\
        \cmidrule(lr){2-3}\cmidrule(lr){4-6} \cmidrule{7-7} & CA & AA & CA &AA &User & Owner\\
        \hline
        Li & Not exist & N/A  & Not exist & $3N_{i,j}\|p\|$ & $3N_{i,j}\|p\|$ & $(3+2N_{a,2})\|p\|$ \\
        Chase & $N_A\|p\|+N_{a,1}\|p\|$ & $(N_i+1)\|p\|$ & $\|p\|$ & $N_{i,j}\|p\|$ & $(N_{i,j}+1)\|p\|$ & $(2+N_{a,2})\|p\|$ \\
        Chase & Not exist & $(N_A-1)\|p\|$ & Not exist & $(N_{i,j}+5)\|p\|$ & $5(N_A-1)\|p\|+N_{i,j}\|p\|$ & $(2+N_{a,2})\|p\|$ \\     
        \hline
        \hline
    \end{tabular}
\end{table*}
\fi

Note that our design goal is to protect the privacy of sensory data, indication vectors and weights for each worker.
In this regard, we present the following theorem.
% That is to say, the privacy of $x_m^k$, $\phi_m^k$ and $w_k$ for each worker $k$ will not be disclosed to $S_0$ and $S_1$.

\begin{theorem}
  Suppose that workers, $S_0$ and $S_1$ satisfy the threat model in this paper, the additively homomorphic cryptosystem and arithmetic sharing are secure, then the privacy of workers' sensory data, indication vectors and weights can be protected under the proposed scheme.
\end{theorem}

{\em Proof.} In our threat model, each entity is assumed to be semi-honest, and two servers are non-colluding.
% Namely, they will honestly follow 
Since workers do not take part in the iteration phase, we only need to consider the privacy of $x_m^k$, $\phi_m^k$ and $w_k$ are not disclosed to $S_0$ and $S_1$ for each worker $k$.

For $S_0$, it only knows $\{x_{m,0}^k, \phi_{m,0}^k, \tilde{\phi}_{m,0}^k\}_{m=1}^M$, $C_k$, $C_5^m$ and $C_6^m$.
Although $S_0$ can decrypt $C_k$, $C_5^m$ and $C_6^m$ and further obtain the perturb weight $\tilde{w}_k$ and the aggregation information such as $\sum_{k=1}^K w_k x_m^k$ and $\sum_{k=1}^K w_k \phi_m^k$.
Since $x_{m,1}^k$ and $\phi_{m,1}^k$ are obtained randomly by worker $k$, $b_k$ is chosen randomly by $S_1$.
Without knowing $x_{m,1}^k$, $\phi_{m,1}^k$ and $b_k$, $S_0$ cannot infer $x_m^k$, $\phi_m^k$ and $w_k$ for worker $k$.

For $S_1$, it only knows $\{x_{m,1}^k, \phi_{m,1}^k, \tilde{\phi}_{m,1}^k\}_{m=1}^M$, $C_0^k$, $C_{pack1}$ and $C_{pack2}$.
Similarly, since $x_{m,0}^k$ and $\phi_{m,0}^k$ are generated randomly by worker $k$, $S_1$ cannot infer $x_m^k$ and $\phi_m^k$ for worker $k$.
Note that $C_0^k$, $C_{pack1}$ and $C_{pack2}$ are ciphertexts under additively homomorphic cryptosystem, $S_1$ has no mechanism to decrypt them without the private key $sk$, and hence cannot learn worker's weight $w_k$ even it knows the ciphertext $C_k$.

Furthermore, we present the security comparisons between the proposed scheme with state-of-the-art schemes.
As shown in Table~\ref{tab1}, only the encrypted CATD and our proposed scheme can deal with the sparse data scenarios.
But the encrypted CATD cannot guarantee the privacy of indicator privacy, which means server can learn the information which objects are observed by a worker. 

\begin{table}[htb]
  \centering
  \caption{Secure Comparison with Various Schemes}~\label{tab1}
  \linespread{1.3}\selectfont
  \begin{adjustbox}{max width=0.5\textwidth}
  \begin{tabular}{ccccc}
    \hline
    \hline
    % \multirow{2}*{Schemes} & \multirow{2}*{Sensory data privacy} & Weight privacy & Indicator privacy & User non-interactive \\
    Schemes & \makecell[c]{Sensory \\ Data Privacy} & \makecell[c]{Weight \\ Privacy} & \makecell[c]{Sparse Data \\ Support} & \makecell[c]{Indicator \\ Privacy} \\
    % Schemes & Sensory data privacy & Weight privacy & Indicator privacy & User non-interactive \\
    \hline
    $L$-PPTD~\cite{miao_lightweight_2017} & $\surd$ & $\surd$ & $\times$ & - \\
    $L^2$-PPTD~\cite{miao_lightweight_2017} & $\surd$ & $\times$ & $\times$ & - \\
    EPTD~\cite{xu_efficient_2019} & $\surd$ & $\surd$ & $\times$ & - \\
    RPTD-I~\cite{zhang_reliable_2019} & $\surd$ & $\surd$ & $\times$ & - \\
    RPTD-II~\cite{zhang_reliable_2019} & $\surd$ & $\surd$ & $\times$ & - \\
    InPPTD~\cite{xue_inpptd_2020} & $\surd$ & $\surd$ & $\times$ & - \\
    Encrypted CATD~\cite{zheng_learning_2018} & $\surd$ & $\surd$ & $\surd$ & $\times$ \\
    Our Propsed Scheme & $\surd$ & $\surd$ & $\surd$ & $\surd$ \\
    \hline
    \hline
  \end{tabular}  
  \end{adjustbox}
\end{table}

\subsection{Efficiency Analysis}
{\em 1) Computation Overheads:} Since each worker $k$ only need to calculate $y_k$ and $\{\tilde{\phi}_m^k\}_{m=1}^M$, and then split $\{x_m^k, \phi_m^k, \tilde{\phi}_m^k\}_{m=1}^M$ into two parts, there are no complicated calculations for workers.
% The computation overheads of workers are low, 
The computation overhead for each worker is $O(M)$.
For $S_0$, it has to take $O(KM+K)$ encryptions and $O(K)$ decryptions in secure weight update phase, and take $O(KM)$ encryptions and $O(M)$ decryptions in secure truth update phase.
For $S_1$, it has to take $O(KM)$ ciphertext multiplications and $O(KM)$ ciphertext exponentiations in secure weight update phase.
% first need to calculate the ciphertext $C_0^k$ for each worker $k$, then it has to encrypts $\{x_{m,0}^k, (x_{m,0}^k)^2, \tilde{\phi}_{m,0}^k,\tilde{\phi}_{m,0}^k\cdot x_{m,0}^k\}_{m,k=1}^{M,K}$ repectively.

{\em 2) Communication Overheads:}

\section{Performance Evaluation}\label{sec7}
In this section, we evaluate the performance of the propose scheme in terms of accurancy, convergence, computation cost and communication cost.
Specifically, we choose Paillier homomorphic cryptosystem~\cite{paillier_public-key_1999} as the additively homomorphic cryptosystem in our scheme.
All procedures are conducted on a computer with an Intel Core i5-10400 CPU (4.30 GHZ) and 16GB RAM running Linux operation system.
All experiments are executed 10 times and the finally results are given in average.
% The experiments are performed on a server with a 1.5 GHZ ARM Cortex-A71 CPU and 4GB RAM running Debian Linux operation system.
For the sake of illustration, we denote $\gamma$ as the sparsity of sensory data, and $\gamma$ is defined as $\gamma = (1 - \sum_{m=1}^M\sum_{k=1}^K\phi_m^k) / (M\cdot K)$.
Intuitively, as $\gamma=0.6$, the average amount of sensory data uploaded by a worker is less than a half of $M$.

\subsection{Accuracy}
Since the CATD framework is adopted as the fundamental truth discovery algorithm in our proposed scheme, we first measure the accuracy of estimated ground truth between our proposed scheme and CATD.
Similar to~\cite{zhang_reliable_2019,xue_inpptd_2020}, we use the Root of Mean Squared Error (RMSE) defined as $(\sum_{m=1}^M (x_m^* - \hat{x}_m)/M)^{\frac{1}{2}}$ to evaluate the deviation between the estimated truths $\{x_m^*\}_{m=1}^M$ and the real ground truths $\{\hat{x}_m\}_{m=1}^M$.
In this experiment, the number of objects and sparsity of sensory data are fixed as 20 and 0.2 respectively, the number of workers is varied from 10 to 30.
As shown in Figure, we can observe that the proposed scheme achieves the similar accuracy to the baseline algorithm CATD.
Moreover, the estimate truths is closer to the real ground truths with the increase of number of workers.

To further analyze the impact of sparsity $\gamma$ for accuracy, we conduct the experiment under different sparsity settings from 0.2 to 0.6.
The results in Figure show that even the sparisity as high as 0.6, the accuracy is still acceptable.

% with the increase of 
% our proposed scheme 
% To analyze the impact of sparsity $\gamma$, we conduct the experiment with different sparsity setting.
% As shown is Figure, 

\subsection{Convergence}
As for convergence, we use $\sum_{m=1}^M (x_m^t - x_m^{t-1})^2$ as the convergence value in the $t$-th iteration, where $x_m^t$ is the estimated truth in $t$-th iteration and $x_m^0$ is randomly initialized.
In this experiment, the number of workers and objects are fixed as 10 and 20 respectively.
As illustrated in Figure , the convergence speed is very fast at the first few iterations.
Meanwhile, in the same conditions, sensory data with higher sparsity need more rounds of iteration to meet a small convergence value.
% the convergence value is larger 
% The results are presented in Figure .

\subsection{Efficiency Evaluation}
In this part, we measure the performance of computation overhead and communication overhead respectively.
In this experiment, the sparsity is fixed as 0.2 by default.
Hereafter, unless otherwise stated, the default sparsity is set to 0.2.
% As for computation overheads, first we 
Table lists the computation overhead of workers and $S_0$ in non-iteration phases including upload phase and pre-processing phase with the number of objects ranging from 20 to 100.
Here, the number of workers is fixed as 10.
We observe the computation cost of workers is very small since there is no heavy cryptographic operations on the workers' side.
% Since workers do not need to execute heavy cryptographic operation, the computation cost on the workers' side is minimal compared to $S_0$

\begin{table}[htbp]
  \centering
  \caption{Computation Overhead in Non-Iteration Phase}
  \linespread{1.3}\selectfont
  \begin{adjustbox}{max width=0.5\textwidth}
  \begin{tabular}{l l c c c}
    \hline
    \hline
    \multicolumn{2}{c}{\multirow{2}*{Number of Workers and Objects}} & \multicolumn{1}{c}{Upload Phase} & \multicolumn{1}{c}{Pre-Processing Phase} \\
    \cmidrule(lr){3-3}\cmidrule(lr){4-4} & & Workers & $S_0$ \\
    \hline
     \multirow{3}*{$K=10$} & $M=20$ & & \\
      & $M=40$ & & \\
      & $M=60$ & & \\
     \cmidrule(lr){1-2}
     \multirow{3}*{$M=20$} & $K=20$ & & \\
     & $K=40$ & & \\
     & $K=60$ & & \\
    \hline
    \hline
  \end{tabular}
  \end{adjustbox}
\end{table}

As for the iteration phases, we measure the computation cost of $S_0$ and $S_1$ under different number of workers and objects for each iteration.
% Figure (a) shows the impact of the number of 
We note that the number of objects is fixed as 20 in Figure (a), and the number of workers is fixed as 20 in Figure (b).
Overall, the experiment results show that the computation cost for $S_0$ is much less compared to $S_1$ in the same condition.
Consider the convergence speed is very fast, the results are quite acceptable for truth discovery in reality.
% servers usually have sufficient computation capability in reality, the results are quite acceptable 

For communication overhead, 

\begin{table}[htbp]
  \centering
  \caption{Computation Overhead in Non-Iteration Phase}
  \linespread{1.3}\selectfont
  \begin{adjustbox}{max width=0.5\textwidth}
  \begin{tabular}{l l c c c c}
    \hline
    \hline
    % \multirow{2}*{\makecell[c]{Number \\ of Workers}}
    \multicolumn{2}{c}{\multirow{2}*{Number of Workers and Objects}} &  \multicolumn{1}{c}{Upload Phase} & \multicolumn{1}{c}{Pre-Processing Phase} & \multicolumn{2}{c}{Iteration Phases} \\
    \cmidrule(lr){3-3}\cmidrule(lr){4-4} \cmidrule(lr){5-6} & & Workers to Servers & $S_0$ to $S_1$ & $S_0$ to $S_1$ & $S_1$ to $S_0$ \\
    \hline
    \multirow{3}*{$K=10$} & $M=20$ & & & \\
    & $M=40$ & & &\\
    & $M=60$ & & &\\
    \cmidrule(lr){1-2}
    \multirow{3}*{$M=20$} & $K=20$ & & & \\
    & $K=40$ & & &\\
    & $K=60$ & & &\\
    \hline
    \hline
  \end{tabular}
  \end{adjustbox}
\end{table}

\section{Conclusion}\label{sec8}
In this paper, we propose a privacy-preserving truth discovery scheme targeted for sparse data scenarios.
Unlike other related researches, we carefully discuss the privacy-preserving issues for truth discovery when sensory data provided by workers are sparse.
We further present a scheme to guarantee these requirements by utilizing additively homomorphic cryptosystem based on CATD framework.
Through the analysis of security and efficiency, our proposed scheme can provide the privacy protection of workers' sensory data, weights and indication vectors with a low computation and communication overhead on the workers' side.
% protect the privacy of workers' sensory data, weights and indication vectors with a low computation and communication overhead on the workers' side.
Finally, extensive experiments also indicate that the proposed scheme is practical in the real mobile crowdsensing systems.

\bibliographystyle{IEEEtran}
\bibliography{ref}

\vspace{12pt}

\end{document}