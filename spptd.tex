\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage[OT1]{fontenc}
\usepackage{xcolor}
\usepackage{multirow,makecell,booktabs}
\usepackage{adjustbox,threeparttable}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\ifCLASSOPTIONcompsoc
\usepackage[caption=false, font=normalsize, labelfont=sf, textfont=sf]{subfig}
\else
\usepackage[caption=false, font=footnotesize]{subfig}
\fi
% \usepackage[colorlinks]{hyperref}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Privacy-Preserving Truth Discovery for Sparse Data in Mobile Crowdsensing Systems\\
% \title{Privacy-preserving truth discovery in sparse mobile crowd sensing systems\\
% {\footnotesize \textsuperscript{*}Note: Sub-titles are not captured in Xplore and
% should not be used}
% \thanks{Identify applicable funding agency here. If none, delete this.}
}

\author{\IEEEauthorblockN{xxx}
\IEEEauthorblockA{School of Cyber Security, University of Science and Technology of China, Hefei, Anhui 230027, China\\
% \textit{University of Science and Technology of China}\\
% Hefei, Anhui 230027, China \\
xxx@ustc.edu.cn}
}
\maketitle

\begin{abstract}
Truth discovery is an effective method to infer truthful information among a large amount of sensory data in mobile crowdsensing systems.
Privacy-preserving truth discovery schemes require the cloud server not to access each participant's sensory data directly, thus the privacy of sensory data can be preserved.
In real practice such as sparse crowdsensing, it is common that the sensory data collected by some participants are sparse, which implies that the privacy of whether or not a participant collects specific data also needs to be protected.
However, existing privacy-preserving truth discovery schemes do not consider such sparse data scenarios in mobile crowdsensing systems.
In this paper, we identify the privacy issues in truth discovery when sensory data are sparse.
To address these issues, we design a privacy-preserving truth discovery scheme by employing the additively homomorphic cryptosystem with two non-colluding servers.
Through detailed security analysis and extensive experiments, we demonstrate that our proposed scheme can satisfy strong privacy-preserving requirements with both low computation and communication overheads on the participants' side.
\end{abstract}
\begin{IEEEkeywords}
Truth Discovery, Privacy Preservation, Sparse Data, Mobile Crowdsensing
\end{IEEEkeywords}

\section{Introduction}~\label{sec1}
Over the past few years, developments in the field of cloud computing and the Internet of Things have led to a growing interest in mobile crowdsensing systems.
In a typical mobile crowdsensing system, the cloud server can collect and analyze the sensory data from different mobile devices (e.g., smartphones, wearables, and on-board computers, usually referred to {\em workers}).
 % sensory data are collected by different mobile devices (e.g., smartphones, wearables) with a highly dynamic nature.
% Benefiting from crowd sensing, a cloud server can collect and analyze the sensory data from different terminal devices (usually called sensing workers).
However, the quality of sensory data provided by different workers may vary greatly.
How to estimate the truthful results from various sensory data becomes a major obstacle for the cloud server.
% A major obstacle is that 
 % it is quite difficult for cloud server to derive reliable aggregated result.
To address this challenge, an effective method called truth discovery~\cite{li_resolving_2014,li_confidence-aware_2014,li_conflicts_2016} has been proposed, where the general principle is to estimate each worker's reliability degree (usually referred to {\em weight}) before calculating the truthful result (usually referred to {\em ground truth}).

Though truth discovery can help cloud server to derive ground truth in an effective way, it poses threats to workers' privacy directly.
To achieve privacy preservation, a considerable amount of work has been proposed by utilizing different approaches~\cite{miao_cloud-enabled_2015,miao_lightweight_2017,xu_efficient_2019,zhang_reliable_2019,xue_inpptd_2020}.
% 大多数 基于 CRH， 默认 所有终端 观测 所有对象数据，引出我们的 contribution
Most of these approaches are based on the CRH algorithm~\cite{li_resolving_2014}, which is a representative algorithm of truth discovery in recent years.
The core principle of CRH is that a worker will be assigned a higher weight if the provided sensory data are closer to the ground truths, and the sensory data provided by a worker will be counted more if this worker has a higher weight~\cite{xu_efficient_2019}.
However, the CRH algorithm requires that each worker has to provide sensory data for all sensed objects, which means it fails to consider the situation when a worker only provides sensory data over partial sensed objects.
In a real mobile crowdsensing system, it is quite possible that a worker only senses a few objects for saving power.
Besides, the number of sensory data provided by different workers may depend on various factors such as workers' abilities, objects' types, and the workers' locations.
% Due to the fact that the types of workers differ widely, the number of sensory data provided by different workers may be influenced by workers' abilities, sensory objects' types and other factors such as current locations.
% depend on workers' abilities, sensory objects' types and other factors such as current locations.
% some workers may 
% it will face challenge when a worker only provides sensory data over partial sensed objects.
% It seems impractical in real mobile sensing systems because 
Taking the sparse mobile crowd sensing~\cite{wang_sparse_2016} as an example, the sensed objects represent different sub-areas.
To collect sensory data for all sensed objects, workers need to access all distinct sub-areas within a specific period, which is impractical.
% which infers the sensory values provided by workers are sparse.
In this condition, the sensory data provided by workers are usually sparse.
Thus, it is infeasible to apply recent CRH-based privacy-preserving truth discovery schemes with this situation.

% contribution
In this paper, we first discuss the privacy issues of sparse data for truth discovery and then propose a privacy-preserving truth discovery scheme to deal with these issues.
In particular, our contributions are summarized in the following:
\begin{itemize}
  \item We identify the privacy requirements in the situation of data sparsity for truth discovery and design a novel privacy-preserving truth discovery scheme based on the CATD algorithm.
  % present a novel privacy-preserving truth discovery schemes which 
   % resolve the issues of data sparsity based on the CATD algorithm rather than .
  \item By employing additively homomorphic cryptosystem with two non-colluding
servers, our proposed scheme provides strong privacy preservation for workers in an efficient way where workers do not need to participate in the iteration procedures.
  \item We conduct extensive experiments to evaluate the performance of the proposed scheme, and the results demonstrate that our design is practical in mobile crowdsensing systems.
\end{itemize}

The remainder of this paper is organized as follows.
Section~\ref{sec2} introduces the related work.
The system model and design goals are given in Section~\ref{sec3}.
In Section~\ref{sec4}, we briefly describe the truth discovery algorithm and additively homomorphic cryptosystem.
Section~\ref{sec5} illustrates our proposed scheme in detail.
After that, security analysis and performance evaluation are provided in Section~\ref{sec6} and Section~\ref{sec7} respectively.
Finally, Section~\ref{sec8} concludes this paper.

\section{Related Work}~\label{sec2}
% 基于 CRH
% 基于 CATD
% 为什么它们都不行
Recent studies have attempted to employ various methods such as cryptographic tools and data perturbation techniques to assure privacy preservation for truth discovery.
Generally, these schemes can be categorized into the single-server setting and two-server setting.

% At the early stage of the study, the single cloud server setting was widely adopted in privacy-preserving truth discovery.
% The single server setting is a common architecture in mobile crowdsensing
% For the single server setting, 
The first privacy-preserving truth discovery was presented by Miao et al.~\cite{miao_cloud-enabled_2015} based on the single-server setting.
% The first serious discussions of privacy preservation for truth discovery was presented by Miao et al.~\cite{miao_cloud-enabled_2015}.
They utilized a threshold paillier cryptosystem to encrypt the sensory data so that the workers' privacy can be preserved.
But the computation overhead of threshold homomorphic cryptography is huge.
To reduce the computation overhead, Xu et al.~\cite{xu_efficient_2019} proposed an efficient scheme based on a fault-tolerance perturbation-based protocol called double-masking.
Benefit from the properties of double-masking, workers can drop out at any time point.
% their proposed mechanism is robust to workers dropping out at any time point.
However, while under the single server setting, workers have to participate in the iterations which means that workers need to suffer additional computing and communication overheads.

To reduce the interactions of workers, Miao et al.~\cite{miao_lightweight_2017} proposed $L$-PPTD and $L^2$-PPTD by involving two non-colluding servers.
% workers' overhead, Miao et al.~\cite{miao_lightweight_2017} proposed $L$-PPTD and $L^2$-PPTD by involving two non-colluding servers.
% Different from the single cloud server setting, workers 
After that, more and more schemes are designed under two-server setting (such as~\cite{zhang_lptd_2019,zhang_reliable_2019,xue_inpptd_2020,tang_achieving_2021}).

On the other hand, most of the existing privacy-preserving truth discovery schemes are based on the CRH algorithm, which requires workers to provide sensory data for all objects.
But in the real-world mobile crowdsensing systems (like sparse mobile crowd sensing~\cite{wang_sparse_2016}), it is usually impractical for workers to observe all objects at a specific period.
% The issue of data sparsity in mobile crowdsensing is getting more and more attention from recent years, especially when taking privacy preservation into account.
% According to research~\cite{wang_sparse_2020}, it is important not only to protect the sensory data observed by workers, but also to protect what objects observed by workers.
% There are two types of privacy need to protect, one is the data observed by workers, the other is which objects observed by workers.

Fortunately, there is another truth discovery algorithm called CATD~\cite{li_confidence-aware_2014} for handling long-tail data, which is also feasible for the sparse data situation.
% In comparison, CATD~\cite{li_confidence-aware_2014} is another truth discovery algorithm for handling long-tail data, which is also suitable for the sparse data situation.
Zheng et al.~\cite{zheng_learning_2018} designed an encrypted truth discovery based on CATD under two non-colluding servers where all procedures are conducted in the encrypted domain.
% In this way, workers' sensory data can be preserved 
Their proposed scheme can realize strong privacy protection for workers' sensory data by adopting Garbled Circuit but it fails to take the privacy issues that appeared in sparse data scenarios into account.
% However, according to research~\cite{wang_sparse_2020}, it is important not only to protect the sensory data observed by workers, but also to protect what objects observed by workers.
% The issue of privacy preservation in sparse mobile crowdsensing is getting more and more attention from recent years.
% Research~\cite{wang_sparse_2020} emphasized that it is important not only to protect the sensory data observed by workers, but also to protect what objects observed by workers in sparse mobile crowdsensing.
To the best of our knowledge, there still lacks discussions about the privacy issues for truth discovery in sparse data scenarios.
% especially when taking privacy preservation into account.
% Research~\cite{wang_sparse_2020} emphasized that it is important not only to protect the sensory data observed by workers, but also to protect what objects observed by workers when sensory data  .
% As depicted in Figure xxx, 
% And the existing privacy-preserving scheme based on CATD~\cite{zheng_learning_2018} 
% But the existing privacy-preserving scheme based on CATD~\cite{zheng_learning_2018} only considered the privacy of sensory data 
% To the best of our knowledge, there still lacks research on the two types of privacy for truth discovery in such scenarios.

\section{System Model and Design Goals}\label{sec3}
In this section, we present the system model and describe the problem we target in this paper.
% sparse data problem in MCS.
\subsection{System Model}\label{sec3-A}
Generally, our system model consists of two types of entities: workers and two non-colluding servers. %用图说明
The specific explanations of these entities are listed as follows.
% worker 的作用， cloud server 的作用
\begin{itemize}
  \item \textbf{Workers:} Workers refers to the mobile devices in a mobile crowdsensing system. They are responsible for collecting sensory data of different objects and upload these sensory data to servers. Since most mobile devices are resource-limited, it is not necessary for each worker to collect sensory data of all objects.
  \item \textbf{Servers:} Servers are responsible for analyzing the sensory data of different objects. More specifically, after receiving the uploaded sensory data, these two servers start to estimate the ground truth for each sensory object. In general, we assume that the two servers have sufficient computation and storage capabilities.
  % the agency to analyse the 
\end{itemize}
% Workers are responsible for collecting sensory data of different objects.
% After that, workers need to upload their sensory data to two cloud servers.

In this paper, suppose that there are $M$ objects to be sensed, and the number of workers is $K$.
We denote $x_m^k$ as the sensory data of object $m$ provided by worker $k$.
Moreover, worker $k$ also maintains an indicator vector $[\phi_1^k, \ldots, \phi_M^k]$ to mark the missing sensory objects in which $\phi_m^k = 1$ means worker $k$ has collected the sensory data of object $m$, and $\phi_m^k = 0$ otherwise.
We note that if $\phi_m^k = 0$, then the corresponding $x_m^k = 0$.
Each worker uploads the sensory data and indicator vector to servers.
After that, two cloud servers calculate each worker's weight (denoted by $w_k$ for worker $k$) and finally estimate the ground truth for each object (denoted by $x_m^*$ for object $m$). 
% The goal of two cloud servers is to estimate the ground truth $X^* = \{x_1^*, x_2^*, \ldots, x_M^*\}$ for each sensory object, where $x_m^*$ represents the estimated ground truth for $m$-th object.
\subsection{Design Goals}

The main goal of our proposed scheme is to achieve privacy-preserving truth discovery when sensory data are sparse.
First, we need to identify the privacy requirements in the sparse data situation.
% Research~\cite{wang_sparse_2020} emphasized that it is important not only to protect the sensory data observed by workers, but also to protect what objects observed by workers in sparse mobile crowdsensing.
According to research~\cite{wang_sparse_2020}, the information of which objects are uploaded by a worker may disclose this worker's location trajectory in sparse mobile crowdsensing.
% Taking sparse mobile crowdsensing as an example, the indicator vector may disclose workers' location trajectory~\cite{wang_sparse_2020}.
In other words, the indicator vector for each worker also needs to be preserved.
Therefore, the main goal is to protect workers' privacy including sensory data, indicator vector, and weight for each worker.
Besides, considering that most workers are resource-limited, it is necessary to reduce the computation and communication overheads on the workers' side.

% As in sparse data situation (e.g., sparse crowd sensing), the indicator vector may disclose workers' privacy 
% The main purpose of our scheme is to protect workers' privacy including sensory data, indicator vector, number of sensed objects and weight for each worker.
% Since the sensory data providered by workers are sparse, we should not only consider the privacy of sensory data, but also consider the privacy of indication vectors.

In our proposed scheme, we assume that all entities are semi-honest, which means that both workers and servers will honestly execute the protocols, but they are also curious about participants' privacy, such as workers' sensory data, workers' weights, and so on.
Besides, the two servers in our scheme are non-colluding, which is a common assumption in most two-server models~\cite{zhang_lptd_2019,zhang_reliable_2019}.
% 不考虑 恶意 workers， 不考虑 lazy workers
Note that the lazy workers are not considered, since this issue can be solved by integrating incentive mechanism~\cite{xue_inpptd_2020}.
Since the truth discovery algorithm only considers estimating ground truth from existing sensory data, the issues of inferring missing data are out of the scope of this paper and we do not consider them in this work.
% The consideration of malicious workers are also not involved, 
% \section{Problem Statement}
% In this section, we describe the truth discovery and formulate the sparse data problem in crowd sensing systems.

\section{Preliminaries}\label{sec4}
In this section, we introduce the truth discovery algorithm CATD~\cite{li_confidence-aware_2014} and additively homomorphic cryptosystem.
% ABY2.0~\cite{patra_aby20_2020}.

\subsection{CATD}
% CATD 强调与 worker 提交的数量，。。。
In general, the truth discovery algorithm CATD consists of two parts: weight update and truth update.

\textit{1) Weight Update:} Given the ground truth, the weight for each worker $k$ is computed as
\begin{equation}
w_k = \frac{\chi^2_{(1-\alpha/2,\sum_{m=1}^M \phi_m^k)}}{\sum_{m=1}^M \phi_m^k(x_m^k - x_m^*)^2}
\end{equation}
Note that $\chi^2$ denotes the Chi-squared distribution, and the constant $\alpha$ denotes the significant level which is usually a small number such as 0.05.

\textit{2) Truth Update:} Given the weight $w_k$ for each worker $k$, the truth for each object $m$ is computed as
\begin{equation}
x_m^* = \frac{\sum_{k=1}^K w_k x_m^k}{\sum_{k=1}^K \phi_m^k w_k }
\end{equation}

In real applications, to achieve more accurate ground truth values, weight update and truth update should be executed iteratively until the convergence criteria are met.

\subsection{Additively Homomorphic Cryptosystem}\label{sec4-b}
% We adopt additive homomorphic cryptosystem in our proposed scheme.
Generally, an additive homomorphic cryptosystem consists of the following four probabilistic poly-time algorithms.

\begin{itemize}
  \item $\mathsf{Setup}(1^\kappa)\to pp$: Taken the input of security parameter $\kappa$, the algorithm returns the public parameter $pp$. Unless otherwise stated, $pp$ is implicitly fed in the following algorithms.
  \item $\mathsf{KeyGen}(1^\kappa)\to (pk, sk)$: Taken the input of security parameter $\kappa$, the algorithm returns the public key $pk$ and private key $sk$.
  \item $\mathsf{Enc}_{pk}(m)\to c$: Given the message $m$, the encryption algorithm outputs $c$ which is the ciphertext of message $m$.
  \item $\mathsf{Dec}_{sk}(c)\to m$: Given the ciphertext $c$, the decryption algorithm outputs the corresponding plaintext $m$.
\end{itemize}

We called the above public-key cryptosystem is additively homomorphic if it satisfies the following properties in probabilistic polynomial time.

\begin{itemize}
  \item Given two ciphertexts $c_1 = \mathsf{Enc}_{pk}(m_1)$ and $c_2 = \mathsf{Enc}_{pk}(m_2)$, it holds that $\mathsf{Dec}_{sk}(c_1 \cdot c_2) = m_1 + m_2$.
  \item Given a constant $a$ and a ciphertext $c=\mathsf{Enc}_{pk}(m)$, it holds that $\mathsf{Dec}_{sk}(c^a) = a\cdot m$.
\end{itemize}
% \subsection{Additive Secret Sharing among Two Parties}
% Suppose have a secret $x$, $x$ is split into $2$ different additive shares $x_0$ and $x_1$ randomly where satisfying $x_0 + x_1 = x$.
% Then 

\iffalse
\subsection{ABY2.0}

% for secure two-party computation,
ABY2.0 is an efficient mixed-protocol framework which allows two parties to jointly evaluate a function based on their private inputs~\cite{patra_aby20_2020}.
In this paper, we make use of arithmetic sharing and multiplication protocol of ABY2.0 as the building blocks.
Specificly, we use $\{S_0, S_1\}$ to denote the two parties, and all protocols are executed over an $\ell$-bit ring denoted by $\mathbb{Z}_{2^\ell}$.
For a value $v\in\mathbb{Z}_{2^\ell}$, there are two sharing semantics in ABY2.0, as denoted by $[\cdot]$-sharing and $\langle \cdot \rangle$-sharing as follows.

\textit{$[\cdot]$-sharing:} A value $v\in\mathbb{Z}_{2^\ell}$ is said to be $[\cdot]$-sharing among $\{S_0, S_1\}$, which means the party $S_i$ for $i\in\{0,1\}$ holds $[v]_i$ such that $v = [v]_0 + [v]_1$.

\textit{$\langle \cdot \rangle$-sharing:} A value $v\in\mathbb{Z}_{2^\ell}$ is said to be $\langle \cdot \rangle$-sharing among $\{S_0, S_1\}$, which means the party $S_i$ for $i\in\{0,1\}$ holds $\langle v \rangle_i = (\Delta_v, [\delta_v]_i)$, where $\Delta_v = v + \delta_v$.

It is clear that both $[\cdot]$-sharing and $\langle \cdot \rangle$-sharing supoort linear operations.
For example, given the $\langle \cdot \rangle$-sharing of $a,b$ and public constants $c_1,c_2$, $S_i$ can locally compute $\langle y_i \rangle = c_1 \cdot \langle a \rangle_i + c_2 \cdot \langle b \rangle_i$.
But the multiplication protocol is non-trivial, we give a brief describtion at a high level.
For more detail, please refer to~\cite{patra_aby20_2020}.

The multiplication protocol enables two parties to generate $\langle y \rangle$ where $y = ab$ when given the $\langle \cdot \rangle$-sharing of $a,b$.
\fi

% Specifically, we 

\section{The Proposed Scheme}\label{sec5}
\subsection{Overview}
% 设计目标场景
As we mentioned above, our privacy-preserving truth discovery scheme is designed for scenarios where the sensory data provided by workers are sparse.
In the proposed scheme, workers need to upload indicator vectors to mark which objects they observed.
Therefore, it is a challenge to protect the privacy of indicator vectors, sensory data, and workers' weights simultaneously.
Although applying GC is a straightforward method to achieve strong privacy preservation, the generation of GC is still a cumbersome task.

To reduce the complicated operations on the workers' side, we shift all heavy cryptographic operations to the servers' side.
Overall, workers only need to split different data into two parts and then upload it to two servers respectively.
After that, the ground truth can be estimated by two servers.
% compute additive shares for different data, then uploads to two servers respectively.
% To protect workers' privacy and make the procedure efficient, there 
% we design a privacy-preserving protocol by adopting additively homomorphic cryptosystem.
The whole procedure can be divided into  phases: {\em Initialization Phase}, {\em Report Phase}, {\em Pre-Processing Phase} and {\em Iteration Phase}.

\subsection{Initialization Phase}
As described in Section~\ref{sec3-A}, assume that there are $K$ participating workers and $M$ sensing objects in the system.
In this phase, $S_0$ first generates an asymmetric key pair $(pk, sk)$ of the additively homomorphic cryptosystem by invoking $\mathsf{KeyGen}(\cdot)$ in Section~\ref{sec4-b}.
Then $S_0$ sets a small number for the significant level $\alpha$ ($\alpha$ is set to 0.05 by default).
Finally, $S_0$ publishes the public key $pk$ and significant level $\alpha$.

% the public key $pk$ and private $sk$ by invoking $\mathsf{KeyGen}(\cdot)$ described in Section~\ref{sec4-b}.
\subsection{Report Phase}
In this phase, each worker collects sensory data for distinct objects.
Taking worker $k$ as an example, after obtaining a set of sensory data $\{x_m^k\}_{m=1}^M$ and generating an indicator vector $\{\phi_m^k\}_{m=1}^M$, worker $k$ computes $y_k = \chi^2_{(1-\alpha/2, \sum_{m=1}^M \phi_m^k)}$.
Then for each object $m$, worker $k$ computes $\tilde{\phi}_m^k = \phi_m^k / y_k$.
Finally, worker $k$ computes additive shares of $x_m^k$, $\phi_m^k$ and $\tilde{\phi}_m^k$ respectively, i.e., $x_m^k = x_{m,0}^k + x_{m,1}^k$, $\phi_m^k = \phi_{m,0}^k + \phi_{m,1}^k$, $\tilde{\phi}_m^k = \tilde{\phi}_{m,0}^k + \tilde{\phi}_{m,1}^k$ (where $\{x_{m,0}^k, \phi_{m,0}^k, \tilde{\phi}_m^k\}_{m=1}^M$ are chosen randomly), and uploads $\{x_{m,0}^k, \phi_{m,0}^k ,\tilde{\phi}_{m,0}^k\}_{m=1}^M$ to $S_0$, uploads $\{x_{m,1}^k, \phi_{m,1}^k, \tilde{\phi}_{m,1}^k\}_{m=1}^M$ to $S_1$.
When the upload process is complete, worker $k$ can go offline.
% 有的 worker 不想做全部的任务 （放到 introduction 部分）
% After that, each worker obtains a set of sensory data and an indication vector

\subsection{Pre-Processing Phase}
We note that this phase is executed by $S_0$.
For worker $k$, $S_0$ first computes $C_0^k$ as: 
\begin{equation}
  \begin{split}
  C_0^k = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_{m,0}^k \left(x_{m,0}^k\right)^2\right]
  \end{split}
\end{equation}
Then $S_0$ encrypts $\{x_{m,0}^k, (x_{m,0}^k)^2, \tilde{\phi}_{m,0}^k,\tilde{\phi}_{m,0}^k\cdot x_{m,0}^k\}_{m,k=1}^{M,K}$ respectively.
These ciphertexts are typically denoted by $C_{pack1}$.
Finally, $S_0$ sends $\{C_0^k\}_{k=1}^K$ and $C_{pack1}$ to $S_1$.

\subsection{Iteration Phase}
The iteration phase consists of the secure weight update phase and secure truth update phase.
In the secure weight update phase, 
% each worker's weight is estimated based on the ground truth and uploaded data.
% We denote $C_{pack}$ as the set of ciphertexts.
% To give a clear illustration, we denote $C_{pack} = \{\mathsf{E}_{pk}(x_{m,0}^k), \mathsf{E}_{pk}((x_{m,0}^k)^2), \mathsf{E}_{pk}(\tilde{\phi}_{m,0}^k), \mathsf{E}_{pk}(\tilde{\phi}_{m,0}^k x_{m,0}^k)\}_{m=1}^M$.
 % $$\{\mathsf{E}_{pk}(x_{m,0}^k), \mathsf{E}_{pk}((x_{m,0}^k)^2), \mathsf{E}_{pk}(\tilde{\phi}_{m,0}^k), \mathsf{E}_{pk}(\tilde{\phi}_{m,0}^k x_{m,0}^k)\}_{m=1}^M$$ to $S_1$.
upon receiving the ciphertexts, $S_1$ computes $C_1^k$,$C_2^k$,$C_3^k$,$C_4^k$ as follows.
\begin{equation}
  \begin{split}
  C_1^k & = \prod_{m=1}^M\left[ \mathsf{Enc}_{pk}{\left[\left(x_{m,0}^k\right)^2\right]}^{\tilde{\phi}_{m,1}^k} \right] \\
  & = \mathsf{Enc}_{pk}\left[ \sum_{m=1}^M \tilde{\phi}_{m,1}^k \left(x_{m,0}^k\right)^2\right]
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
  C_2^k & =  \prod_{m=1}^M\left[ \left[\mathsf{Enc}_{pk}\left(x_{m,0}^k\right)\right]^{2\left(x_{m,1}^k - x_m^*\right)\tilde{\phi}_{m,1}^k}\right] \cdot \\
          & \qquad \prod_{m=1}^M\left[ \left[\mathsf{Enc}_{pk}\left(\tilde{\phi}_{m,0}^k x_{m,0}^k\right)\right]^{2\left(x_{m,1}^k - x_m^*\right)} \right] \\
          % = & \mathsf{Enc}_{pk}\left[\sum_{m=1}^M 2(x_{m,1}^k - x_m^*)(\tilde{\phi}_{m,1}^k x_{m,0}^k +   \tilde{\phi}_{m,0}x_{m,0}^k)\right]  \\
          & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M 2\tilde{\phi}_m^k x_{m,0}^k\left(x_{m,1}^k - x_m^*\right)\right]  \\
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    C_3^k & = \prod_{m=1}^M\left[ \mathsf{Enc}_{pk}\left(\tilde{\phi}_{m,0}^k\right)^{\left(x_{m,1}^k - x_m^*\right)^2} \right] \\
    & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_{m,0}^k\left(x_{m,1}^k - x_m^*\right)^2\right] \\
    % & = \mathsf{Enc}_{pk}(\sum_{m=1}^M \tilde{\phi}_{m,0}^k \cdot (x_{m,1}^k - x_m^*)^2)
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    C_4^k & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_{m,1}^k \left(x_{m,1}^k - x_m^*\right)^2\right]
  \end{split}
\end{equation}
Then $S_1$ chooses a random value $b_k$ and computes the ciphertexts $C_k$ as 
\begin{equation}
  \begin{split}
    C_k = & \left(C_0^k\cdot C_1^k\cdot C_2^k\cdot C_3^k \cdot C_4^k\right)^{b_k} \\
        % = & \mathsf{Enc}_{pk}\left[b_k\cdot \sum_{m=1}^M \tilde{\phi}_m^k\left(\left(x_{m,0}^k\right)^2 + 2x_{m,0}^k\left(x_{m,1}^k-x_m^*\right) + \left(x_{m,1}^k - x_m^*\right)^2\right)\right]
  \end{split}
\end{equation}
Finally $S_1$ sends $\{C_k\}_{k=1}^K$ to $S_0$.
Note that if this phase is executed for the first time, the initial ground truths $\{x_m^*\}_{m=1}^M$ are chosen randomly.
After receiving $\{C_k\}_{k=1}^K$, $S_0$ first decrypts $C_k$ with its private key and obtains the perturbed weight $\tilde{w}_k$ of worker $k$ as follows,
\begin{equation}
  \begin{split}
    \tilde{w}_k = \frac{1}{\mathsf{Dec}_{sk}\left(C_k\right)} = \frac{w_k}{b_k}
    % \tilde{w}_k = \frac{1}{\mathsf{Dec}_{sk}\left(C_k\right)} = \frac{y_k}{b_k \sum_{m=1}^M \phi_m^k\left(x_m^k - x_m^*\right)^2} = \frac{w_k}{b_k}
  ~\label{eq9}
  \end{split}
\end{equation}
Here we give the correctness analysis of Eq.~\ref{eq9}.
According to the properties of the additively homomorphic cryptosystem, we have
\begin{equation}
  \begin{split}
  C_0^k C_1^k & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_{m,0}^k\left(x_{m,0}^k\right)^2 + \tilde{\phi}_{m,1}^k\left(x_{m,0}^k\right)^2  \right] \\
   & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_m^k\left(x_{m,0}^k\right)^2 \right] \\
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
  C_3^kC_4^k & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \left(\tilde{\phi}_{m,0}^k + \tilde{\phi}_{m,1}^k\right) \left(x_{m,1}^k-x_m^*\right)^2 \right] \\
  & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_m^k\left(x_{m,1}^k - x_m^*\right)^2\right] \\
  \end{split}
\end{equation}
Since $\tilde{\phi}_m^k (x_{m,0}^k)^2 + 2\tilde{\phi}_m^kx_{m,0}^k\left(x_{m,1}^k - x_m^*\right) + \tilde{\phi}_m^k(x_{m,1}^k - x_m^*)^2 = \tilde{\phi}_m^k (x_{m,0}^k + x_{m,1}^k - x_m^*)^2$, then we can further obtain
\begin{equation}
  \begin{split}
  C_k & = \left(C_0^k \cdot C_1^k\cdot C_2^k \cdot C_3^k \cdot C_4^k\right)^{b_k} \\
   & = \left[\mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_m^k (x_{m,0} + x_{m,1} - x_m^*)^2 \right]\right]^{b_k} \\
  & = \mathsf{Enc}_{pk}\left[b_k \sum_{m=1}^M \tilde{\phi}_m^k (x_m - x_m^*)^2 \right] \\
  \end{split}
\end{equation}
Hence, the perturbed weight $\tilde{w}_k$ can be written as
\begin{equation}
  \begin{split}
  \tilde{w}_k & = \frac{1}{\mathsf{Dec}_{sk}\left(C_k\right)} \\
  & = \frac{1}{b_k \sum_{m=1}^M \tilde{\phi}_m^k (x_m - x_m^*)^2} \\
  & = \frac{1}{b_k} \cdot \frac{y_k}{\sum_{m=1}^M \phi_m^k (x_m - x_m^*)^2} \\
  & = \frac{w_k}{b_k} \\
  \end{split}
\end{equation}
Therefore, the correctness of Eq.~\ref{eq9} holds.

% \begin{equation}
  % \begin{split}
    % \mathsf{Enc}_{pk}(1/w_k) & = C_0 \cdot C_1 \cdot C_2 \cdot C_3 \cdot C_4 \\
    % & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_m^k\cdot (x_{m,0}^k)^2 + 2\cdot\tilde{\phi}_m^k x_{m,0}^k (x_{m,1}^k-x_m^*) + \tilde{\phi}_m^k (x_{m,1}^k - x_m^*)^2 \right] \\
    % & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_m^k (x_m^k - x_m^*)^2 \right] \\
    % & = \mathsf{Enc}_{pk}\left[\frac{\sum_{m=1}^M \phi_m^k (x_m^k - x_m^*)^2}{y} \right] \\
  % \end{split}
% \end{equation}

% In the weight update phase, $S_0$ obtains the perturbed weight $\tilde{w}_k$ for each worker $k$.
In the truth update phase, $S_0$ first encrypts $\{\tilde{w}_k\}_{m=1}^K$ and $\{\tilde{w}_k\cdot x_{m,0}^k, \tilde{w}_k\cdot \phi_{m,0}^k\}_{m,k=1}^{M,K}$ respectively.
% To estimate the ground truth for each object, $S_0$ first encrypts $\{\tilde{w}_k, \tilde{w}_k\cdot x_{m,0}^k, \tilde{w}_k\cdot \phi_{m,0}^k\}_{m,k=1}^{M,K}$.
We denote the sets of ciphertexts as $C_{pack2}$.
Finally $S_0$ sends $C_{pack2}$ to $S_1$.

After receiving the ciphertexts, $S_1$ computes $C_5^m$ and $C_6^m$ as follows,
\begin{equation}
  \begin{split}
    C_5^m & = \prod_{k=1}^K\left[\left[\mathsf{Enc}_{pk}\left(\tilde{w}_k\cdot x_{m,0}^k\right)\cdot \left[\mathsf{Enc}_{pk}\left(\tilde{w}_k\right)\right]^{x_{m,1}^k}\right]^{b_k} \right] \\
    & = \mathsf{Enc}_{pk}\left[\sum_{k=1}^K b_k \tilde{w_k}x_m^k\right]\\
    & = \mathsf{Enc}_{pk}\left[\sum_{k=1}^K w_kx_m^k\right] \\
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    C_6^m & = \prod_{k=1}^K \left[ \left[ \mathsf{Enc}_{pk}(\tilde{w}_k\cdot \phi_{m,0}^k) \cdot \left[\mathsf{Enc}_{pk}(\tilde{w}_k)\right]^{\phi_{m,1}^k}\right]^{b_k} \right] \\
     & = \mathsf{Enc}_{pk}\left[\sum_{k=1}^K b_k \tilde{w}_k\phi_m^k \right] \\
     & = \mathsf{Enc}_{pk}\left[\sum_{k=1}^K w_k\phi_m^k \right] \\
    % C_6^m = \prod_{k=1}^K \left[ \letf[\mathsf{Enc}_{pk}(\tilde{w}_k\cdot \phi_{m,0}^k)\right]^{b_k} \cdot \mathsf{Enc}_{pk}()\right]
  \end{split}
\end{equation}
% Then $S_0$ encrypts $\{\tilde{w}_k\}_{k=1}^K$, we denotes the set of ciphertexts by $C_{pack2}^k$.
% Finally $S_0$ sends $\{C_5^m, C_6^m\}_{m=1}^M$ and $\{C_{pack2}^k\}_{k=1}^K$ to $S_1$.
% After receiving the ciphertexts, $S_1$ computes $C_7^m$ and $C_8^m$ as follows,
% \begin{equation}
  % \begin{split}
    % C_7^m = \mathsf{Enc}_{pk}(\tilde{w}_k)
  % \end{split}
% \end{equation}
Finally $S_1$ sends $\{C_5^m\}_{m=1}^M$ and $\{C_6^m\}_{m=1}^M$ to $S_0$.
Then $S_0$ decrypts these ciphertexts and obtains the groud truth as follows,
\begin{equation}
  \begin{split}
    x_m^* = \frac{\mathsf{Dec}_{sk}(C_5^m)}{\mathsf{Dec}_{sk}(C_6^m)} = \frac{\sum_{k=1}^K w_kx_m^k}{\sum_{k=1}^K w_k\phi_m^k}
  \end{split}
\end{equation}

\section{System Analysis}\label{sec6}
\subsection{Security Analysis}

\iffalse
\begin{table*}[t]
    \centering
    \caption{Communication Overhead}
    \linespread{1.3}\selectfont
    \begin{tabular}{l c c c c c c}
        \hline
        \hline
        \multirow{2}*{Scheme} &  \multicolumn{2}{c}{System Initialization} & \multicolumn{3}{c}{Key Generation and Distribution}& Encryption/Decryption\\
        \cmidrule(lr){2-3}\cmidrule(lr){4-6} \cmidrule{7-7} & CA & AA & CA &AA &User & Owner\\
        \hline
        Li & Not exist & N/A  & Not exist & $3N_{i,j}\|p\|$ & $3N_{i,j}\|p\|$ & $(3+2N_{a,2})\|p\|$ \\
        Chase & $N_A\|p\|+N_{a,1}\|p\|$ & $(N_i+1)\|p\|$ & $\|p\|$ & $N_{i,j}\|p\|$ & $(N_{i,j}+1)\|p\|$ & $(2+N_{a,2})\|p\|$ \\
        Chase & Not exist & $(N_A-1)\|p\|$ & Not exist & $(N_{i,j}+5)\|p\|$ & $5(N_A-1)\|p\|+N_{i,j}\|p\|$ & $(2+N_{a,2})\|p\|$ \\     
        \hline
        \hline
    \end{tabular}
\end{table*}
\fi

Note that our design goal is to protect the privacy of sensory data, indicator vectors and weights for each worker.
In this regard, we present the following theorem.
% That is to say, the privacy of $x_m^k$, $\phi_m^k$ and $w_k$ for each worker $k$ will not be disclosed to $S_0$ and $S_1$.

\begin{theorem}
  Suppose that workers, $S_0$ and $S_1$ satisfy the threat model in this paper, the additively homomorphic cryptosystem is secure, then the privacy of workers' sensory data, indicator vectors, and weights can be protected under the proposed scheme.
\end{theorem}

{\em Proof.} In this paper, each entity is assumed to be semi-honest, and two servers are non-colluding.
% Namely, they will honestly follow 
Since workers do not take part in the iteration phase, we only need to consider that the privacy of $x_m^k$, $\phi_m^k$ and $w_k$ are not disclosed to $S_0$ and $S_1$ for each worker $k$.

For $S_0$, it only knows $\{x_{m,0}^k, \phi_{m,0}^k, \tilde{\phi}_{m,0}^k\}_{m=1}^M$, $C_k$, $C_5^m$ and $C_6^m$.
$S_0$ can decrypt $C_k$, $C_5^m$, $C_6^m$, and further obtain the perturb weight $\tilde{w}_k$ along with the aggregation information such as $\sum_{k=1}^K w_k x_m^k$ and $\sum_{k=1}^K w_k \phi_m^k$.
Since $x_{m,1}^k$ and $\phi_{m,1}^k$ are generated randomly by worker $k$, $b_k$ is chosen randomly by $S_1$.
Without knowing $x_{m,1}^k$, $\phi_{m,1}^k$ and $b_k$, $S_0$ cannot infer $x_m^k$, $\phi_m^k$ and $w_k$ for worker $k$.

For $S_1$, it only knows $\{x_{m,1}^k, \phi_{m,1}^k, \tilde{\phi}_{m,1}^k\}_{m=1}^M$, $C_0^k$, $C_{pack1}$ and $C_{pack2}$.
Similarly, since $x_{m,0}^k$ and $\phi_{m,0}^k$ are generated randomly by worker $k$, $S_1$ cannot infer $x_m^k$ and $\phi_m^k$ for worker $k$.
Note that $C_0^k$, $C_{pack1}$ and $C_{pack2}$ are ciphertexts under additively homomorphic cryptosystem, $S_1$ has no mechanism to decrypt them without the private key $sk$, and hence cannot learn worker's weight $w_k$ even it knows the ciphertext $C_k$.

Furthermore, we present the security comparison between the proposed scheme with state-of-the-art schemes.
As shown in TABLE~\ref{tab:security}, only the encrypted CATD and our proposed scheme can deal with the sparse data scenarios.
But the encrypted CATD cannot guarantee the privacy of indicator privacy, which means the server can learn the information of which objects are observed by a worker. 

\begin{table}[htb]
  \centering
  \caption{Security Comparison with Various Schemes}~\label{tab:security}
  \linespread{1.3}\selectfont
  \begin{adjustbox}{max width=0.5\textwidth}
  \begin{tabular}{ccccc}
    \hline
    \hline
    % \multirow{2}*{Schemes} & \multirow{2}*{Sensory data privacy} & Weight privacy & Indicator privacy & User non-interactive \\
    Schemes & \makecell[c]{Sensory \\ Data Privacy} & \makecell[c]{Weight \\ Privacy} & \makecell[c]{Sparse Data \\ Support} & \makecell[c]{Indicator \\ Privacy} \\
    % Schemes & Sensory data privacy & Weight privacy & Indicator privacy & User non-interactive \\
    \hline
    $L$-PPTD~\cite{miao_lightweight_2017} & $\surd$ & $\surd$ & $\times$ & - \\
    $L^2$-PPTD~\cite{miao_lightweight_2017} & $\surd$ & $\times$ & $\times$ & - \\
    EPTD~\cite{xu_efficient_2019} & $\surd$ & $\surd$ & $\times$ & - \\
    RPTD-I~\cite{zhang_reliable_2019} & $\surd$ & $\surd$ & $\times$ & - \\
    RPTD-II~\cite{zhang_reliable_2019} & $\surd$ & $\surd$ & $\times$ & - \\
    InPPTD~\cite{xue_inpptd_2020} & $\surd$ & $\surd$ & $\times$ & - \\
    Encrypted CATD~\cite{zheng_learning_2018} & $\surd$ & $\surd$ & $\surd$ & $\times$ \\
    Our Propsed Scheme & $\surd$ & $\surd$ & $\surd$ & $\surd$ \\
    \hline
    \hline
  \end{tabular}  
  \end{adjustbox}
\end{table}

% \subsection{Efficiency Analysis}
% {\em 1) Computation Overheads:} Since each worker $k$ only need to calculate $y_k$ and $\{\tilde{\phi}_m^k\}_{m=1}^M$, and then split $\{x_m^k, \phi_m^k, \tilde{\phi}_m^k\}_{m=1}^M$ into two parts, there are no complicated calculations for workers.
% % The computation overheads of workers are low, 
% The computation overhead for each worker is $O(M)$.
% For $S_0$, it has to take $O(KM+K)$ encryptions and $O(K)$ decryptions in secure weight update phase, and take $O(KM)$ encryptions and $O(M)$ decryptions in secure truth update phase.
% For $S_1$, it has to take $O(KM)$ ciphertext multiplications and $O(KM)$ ciphertext exponentiations in secure weight update phase.
% first need to calculate the ciphertext $C_0^k$ for each worker $k$, then it has to encrypts $\{x_{m,0}^k, (x_{m,0}^k)^2, \tilde{\phi}_{m,0}^k,\tilde{\phi}_{m,0}^k\cdot x_{m,0}^k\}_{m,k=1}^{M,K}$ repectively.
% {\em 2) Communication Overheads:}

\section{Performance Evaluation}\label{sec7}
In this section, we evaluate the performance of the proposed scheme in terms of accuracy, convergence, computation overhead, and communication overhead.
Specifically, we choose Paillier homomorphic cryptosystem~\cite{paillier_public-key_1999} as the additively homomorphic cryptosystem in our scheme.
All procedures are conducted on a computer with an Intel Core i5-10400 CPU (4.30 GHz) and 16GB RAM running Linux operation system.
All experiments are executed 10 times and take the average results.
% The experiments are performed on a server with a 1.5 GHZ ARM Cortex-A71 CPU and 4GB RAM running Debian Linux operation system.
For the sake of illustration, we use $\gamma$ to denote the sparsity of sensory data, and $\gamma$ is defined as $\gamma = 1 - (\sum_{m=1}^M\sum_{k=1}^K\phi_m^k) / (M\cdot K)$.
% Intuitively, as $\gamma=0.6$, the average amount of sensory data uploaded by a worker is less than a half of $M$.

\subsection{Accuracy}
Since the CATD framework is adopted as the fundamental truth discovery algorithm in our proposed scheme, we first measure the accuracy of estimated ground truth between our proposed scheme and CATD.
Similar to~\cite{zhang_reliable_2019,xue_inpptd_2020}, we use the Root of Mean Squared Error (RMSE) defined as $(\sum_{m=1}^M (x_m^* - \hat{x}_m)/M)^{\frac{1}{2}}$ to evaluate the deviation between the estimated truths $\{x_m^*\}_{m=1}^M$ and the real ground truths $\{\hat{x}_m\}_{m=1}^M$.
In this experiment, the number of objects and sparsity of sensory data are fixed as 20 and 0.2 respectively, the number of workers is varied from 5 to 25.
As shown in Fig.~\ref{fig:rmse1}, we can observe that the proposed scheme achieves a similar accuracy to the baseline algorithm CATD.
Additionally, the estimated truths are closer to the real ground truths with the increase in the number of workers.
\begin{figure}[htbp]
  \centering 
  \subfloat[Accuracy Comparison with CATD]{ 
    \label{fig:rmse1}
    \includegraphics[width=0.5\linewidth]{figures/rmse1.pdf}}
  \subfloat[The Impact of Different Sparsity]{ 
    \label{fig:rmse2} 
    \includegraphics[width=0.5\linewidth]{figures/rmse2.pdf}} 
  \caption{Accuracy Evaluation}
  \label{fig:rmse} 
\end{figure}
% \begin{figure}[htbp]
%   \centering
%   \label{fig:rmse1}
%   \includegraphics[width=0.9\linewidth]{figures/rmse1.eps}
%   \caption{Accuracy comparision with CATD}
% \end{figure}
To further analyze the impact of sparsity $\gamma$ for accuracy, we conduct the experiment under different sparsity settings from 0.2 to 0.6.
The results in Fig.~\ref{fig:rmse2} show that in a high sparse situation, it is necessary to recruit more workers to decrease the deviation between estimated truths with real ground truths.
% in the same conditions the sensory data is more sparse, the deviation 
% even the sparsity as high as 0.6, the accuracy is still acceptable.
% \begin{figure}[htbp]
%   \label{fig:rmse2}
%   \includegraphics[width=\linewidth]{figures/rmse2.eps}
%   \caption{Accuracy comparision with CATD}
% \end{figure}

% with the increase of 
% our proposed scheme 
% To analyze the impact of sparsity $\gamma$, we conduct the experiment with different sparsity setting.
% As shown is Figure, 

\subsection{Convergence}
As for convergence, we use $\sum_{m=1}^M (x_m^t - x_m^{t-1})^2$ as the convergence value in the $t$-th iteration, where $x_m^t$ is the estimated truth in $t$-th iteration and $x_m^0$ is randomly initialized.
In this experiment, the number of workers and objects are fixed as 10 and 20 respectively.
As illustrated in Fig.~\ref{fig:conver}, the convergence speed is very fast at the first few iterations.
Meanwhile, the sparsity has little impact on the convergence.
% in the same conditions, sensory data with higher sparsity need more rounds of iteration to meet a small convergence value.
% the convergence value is larger 
% The results are presented in Figure .
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.75\linewidth]{figures/conver.pdf}
  \caption{Convergence Evaluation}
  \label{fig:conver}
\end{figure}

\subsection{Efficiency Evaluation}
In this part, we measure the performance of computation overhead and communication overhead respectively.
In this experiment, the sparsity is fixed as 0.2 by default.
Hereafter, unless otherwise stated, the default sparsity is set to 0.2.
% As for computation overheads, first we 
TABLE~\ref{tab:computation} lists the computation overhead of workers and $S_0$ in non-iteration phases including the report phase and pre-processing phase with the different number of objects and workers.
 % ranging from 20 to 100.
% Here, the number of workers is fixed as 10.
We observe the computation cost of workers is negligible compared to $S_0$ since there are no heavy cryptographic operations on the workers' side.
% Since workers do not need to execute heavy cryptographic operation, the computation cost on the workers' side is minimal compared to $S_0$

\begin{table}[htbp]
  \centering
  \caption{Computation Overhead in Non-Iteration Phases (S)}~\label{tab:computation}
  \linespread{1.3}\selectfont
  \begin{adjustbox}{max width=0.5\textwidth}
  \begin{tabular}{l l c c c}
    \hline
    \hline
    \multicolumn{2}{c}{\multirow{2}*{Number of Workers and Objects}} & \multicolumn{1}{c}{Report Phase} & \multicolumn{1}{c}{Pre-Processing Phase} \\
    \cmidrule(lr){3-3}\cmidrule(lr){4-4} & & Workers & $S_0$ \\
    \hline
     \multirow{3}*{$K=10$} & $M=20$ & 0.0011 & 6.93 \\
      & $M=40$ & 0.0011 & 20.98 \\
      & $M=60$ & 0.0012 & 34.86 \\
     \cmidrule(lr){1-2}
     \multirow{3}*{$M=20$} & $K=20$ & 0.0049 & 14.04\\
     & $K=40$ & 0.0059 & 42.41\\
     & $K=60$ & 0.0104 & 70.92 \\
    \hline
    \hline
  \end{tabular}
  \end{adjustbox}
\end{table}

% servers usually have sufficient computation capability in reality, the results are quite acceptable 
\begin{figure}[!ht]
  \centering 
  \subfloat[$K = 10 $]{ 
    \label{fig:comp1}
    \includegraphics[width=0.5\linewidth]{figures/time_obj.pdf}}
  \subfloat[$M = 20$]{ 
    \label{fig:comp2} 
    \includegraphics[width=0.5\linewidth]{figures/time_work.pdf}} 
  \caption{Computation Overhead for Each Iteration}
  \label{fig:comp} 
\end{figure}

\begin{table}[!ht]
  \centering
  \caption{Communication Overhead (KB)}~\label{tab:communication}
  \linespread{1.3}\selectfont
  \begin{adjustbox}{max width=0.5\textwidth}
  \begin{tabular}{l l c c c c}
    \hline
    \hline
    % \multirow{2}*{\makecell[c]{Number \\ of Workers}}
    \multicolumn{2}{c}{\multirow{2}*{Number of Workers and Objects}} &  \multicolumn{1}{c}{Report Phase} & \multicolumn{1}{c}{Pre-Processing Phase} & \multicolumn{2}{c}{Iteration Phase} \\
    \cmidrule(lr){3-3}\cmidrule(lr){4-4} \cmidrule(lr){5-6} & & Workers to Servers & $S_0$ to $S_1$ & $S_0$ to $S_1$ & $S_1$ to $S_0$ \\
    \hline
    \multirow{3}*{$K=10$} & $M=20$ & 9.60 & 8.08 & 3.44 & 0.04\\
    & $M=40$ & 19.20 & 16.08 & 6.80 & 0.72\\
    & $M=60$ & 28.80 & 24.08 & 10.16 & 1.04\\
    \cmidrule(lr){1-2}
    \multirow{3}*{$M=20$} & $K=20$ & 19.20 & 16.16 & 6.72 & 0.48\\
    & $K=40$ & 38.40 & 32.32 & 13.28 & 0.64 \\
    & $K=60$ & 57.60 & 48.48 & 19.84 & 0.80 \\
    \hline
    \hline
  \end{tabular}
  \end{adjustbox}
\end{table}

As for the iteration phases, we measure the computation cost of $S_0$ and $S_1$ under different numbers of workers and objects for each iteration.
% Figure (a) shows the impact of the number of 
% Note that the number of workers is fixed as 20 in Figure (a), and the number of workers is fixed as 20 in Figure (b).
As shown in Fig.~\ref{fig:comp}, the computation cost for $S_1$ is much less compared to $S_0$ in the same conditions.
% Overall, the experiment results show that the computation cost for $S_0$ is much less compared to $S_1$ in the same condition.
% Consider the convergence speed is very fast, the results are quite acceptable for truth discovery in reality.
For the communication overhead, TABLE~\ref{tab:communication} reports the communication overhead for each entity in different phases.
It is clear that the communication overhead in the iteration phase is less than that in the non-iteration phase.
% Since 
% Although applying GC is a straightforward method to achieve strong privacy preservation, the generation of GC is still a cumbersome task.
% Considering that 
Note that the alternative privacy-preserving truth discovery scheme~\cite{zheng_learning_2018} based on CATD is implemented by GC.
However, the computation cost of GC generation and the communication of GC transmission are huge.
We demonstrate that both computation and communication overheads on the workers' side are lightweight, and the communication overhead between two servers is also acceptable for truth discovery in reality.
% in real mobile crowdsensing systems.
% our proposed scheme 
% and communication overhead 
% in the real applications, the weight update phase and truth update phase need to be executed many times, our proposed scheme 
% has the advantage of communication over two 

\section{Conclusion}\label{sec8}
In this paper, we propose a privacy-preserving truth discovery scheme targeted for privacy-preserving problems in sparse data scenarios.
% Unlike other related researches, 
First, we carefully discuss the privacy issues for truth discovery when sensory data provided by workers are sparse.
After that, we present a scheme to guarantee these requirements by utilizing additively homomorphic cryptosystem based on the CATD framework.
Finally, through the analysis of security, our proposed scheme can provide the strong privacy protection of workers' sensory data, weights, and indicator vectors at the same time.
% protect the privacy of workers' sensory data, weights and indication vectors with a low computation and communication overhead on the workers' side.
Extensive experiments also indicate that the computation overhead of workers and the communication overhead in the iteration phase are lightweight enough, which implies that the proposed scheme is practical in real mobile crowdsensing systems.
 % both computation and communication overheads on the workers' side are light, 
 

\bibliographystyle{IEEEtran}
\bibliography{ref}

\vspace{12pt}

\end{document}