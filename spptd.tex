\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage[OT1]{fontenc}
\usepackage{xcolor}
% \usepackage[colorlinks]{hyperref}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Privacy-Preserving Truth Discovery for Sparse Data in Mobile Crowdsensing Systems\\
% \title{Privacy-preserving truth discovery in sparse mobile crowd sensing systems\\
% {\footnotesize \textsuperscript{*}Note: Sub-titles are not captured in Xplore and
% should not be used}
% \thanks{Identify applicable funding agency here. If none, delete this.}
}

\author{\IEEEauthorblockN{xxx}
\IEEEauthorblockA{\textit{University of Science and Technology of China}\\
Hefei, Anhui 230027, China \\
xxx@mail.ustc.edu.cn}
}
\maketitle

\begin{abstract}
Truth discovery is an effective method to infer the truthful information among a large amount of sensory data in mobile crowdsensing systems.
Privacy-preserving truth discovery schemes require the cloud servers should not access each participant's sensory data directly when executing truth discovery.
In real practice, it is common that the sensory data collected by some participants are sparse, which implies that the privacy of whether a participant collects a specific data also need to be protected.
However, existing privacy-preserving truth discovery schemes do not consider sparse data scenarios in crowdsensing systems.
In this paper, we address the privacy issues in truth discovery when sensory data are sparse.
By employing additively homomorphic cryptosystem with two non-colluding servers setting, we design an efficient privacy-preserving truth discovery scheme to guarantee strong privacy even in sparse data scenarios.
Moreover, the security analysis and performance evaluation show that our proposed scheme can satisfy the security and privacy-preserving requirements with both low computation and communication overheads.
\end{abstract}

\begin{IEEEkeywords}
Truth Discovery, Privacy Preservation, Sparse Data, Mobile Crowdsensing
\end{IEEEkeywords}

\section{Introduction}~\label{sec1}
Over the past few years, developments in the field of cloud computing and Internet of Things have led to a growing interest in mobile crowdsensing systems.
In a typical mobile crowdsensing system, the cloud server can collect and analyze the sensory data from different mobile devices (e.g., smartphones, wearables and on-board computers, usually referred to {\em workers}).
 % sensory data are collected by different mobile devices (e.g., smartphones, wearables) with a highly dynamic nature.
% Benefiting from crowd sensing, a cloud server can collect and analyze the sensory data from different terminal devices (usually called sensing workers).
However, the quality of sensory data provided by different workers may vary greatly, it is difficult for cloud servers to derive reliable aggregated result.
To address this challenge, a series of methods called truth discovery~\cite{li_resolving_2014,li_confidence-aware_2014,li_conflicts_2016} have been proposed, where the general principle is to estimate each worker's reliability degree (usually referred to {\em weight}) before calculating the truthful result (usually referred to {\em ground truth}).

Though truth discovery can help cloud server to derive ground truth in an effective way, it poses threats to workers' privacy directly.
To achieve privacy preservation, a considerable amount of work has been proposed using different alternatives\cite{miao_cloud-enabled_2015,miao_lightweight_2017,xu_efficient_2019,zhang_reliable_2019,xue_inpptd_2020}.
% 大多数 基于 CRH， 默认 所有终端 观测 所有对象数据，引出我们的 contribution
Most of these approaches are based on CRH algorithm~\cite{li_resolving_2014}, which is a representative algorithm of truth discovery in recent years.
The core principle of CRH is that a worker will be assigned a higher weight if the corresponding sensory data are closer to the ground truths, and the sensory data provided by a worker will be counted more if this worker has a higher weight~\cite{xu_efficient_2019}.
Since the CRH algorithm requires that each worker has to provide data over all sensed objects, it will face challenge when a worker only provides data over partial sensed objects for some reasons.
% It seems impractical in real mobile sensing systems because 
Taking the sparse mobile crowd sensing~\cite{wang_sparse_2016} as an example, the sensed objects represent different sub-areas.
To collect sensory for all sensed objects, workers need to access into distinct sub-areas within a specific period, which is impractical.
% which infers the sensory values provided by workers are sparse.
In this scenario, the sensory data provided by workers are usually sparse.
So, it is infeasible to apply recent CRH-based privacy-preserving truth discovery schemes in this situation.

% contribution
In this paper, we address the privacy issues in sparse data for truth discovery, and propose a privacy-preserving truth discovery scheme to deal with the issues.
In particular, our contributions are summarized in the following:
\begin{itemize}
  \item We identify the privacy requirements in the situation of data sparsity for truth discovery, and design a novel privacy-preserving truth discovery scheme based on CATD algorithm.
  % present a novel privacy-preserving truth discovery schemes which 
   % resolve the issues of data sparsity based on the CATD algorithm rather than .
  \item By employing additively homomorphic cryptosystem with two non-colluding
servers setting, our proposed scheme provides strong privacy for workers in an efficient way where workers do not need to participate the iteration procedure.
  \item We conduct extensive experiments to evaluate the performance of the proposed scheme, and the results demonstrate that our design is practical in real mobile crowdsensing systems.
\end{itemize}

The remainder of this paper is organized as follows.
Section~\ref{sec2} introduces the related work.
The system model and design goals are given in Section~\ref{sec3}.
In Section~\ref{sec4}, we describe the truth discovery algorithm and additively homomorphic cryptosystem.
Section~\ref{sec5} illustrates our proposed scheme in detail.
After that, security analysis and performance analysis are provided in Section~\ref{sec5}.
Finally, Section~\ref{sec6} concludes this paper.

\section{Related Work}~\label{sec2}
% 基于 CRH
% 基于 CATD
% 为什么它们都不行
At the early stage of the study, the single cloud server setting was widely used in PPTD.
The first serious discussions of privacy preservation for truth discovery was presented by Miao et al.~\cite{miao_cloud-enabled_2015}.
They used threshold homomorphic cryptography to encrypt the sensory data and protect works' privacy. 
But the computation overhead of homomorphic cryptography is huge, Xu et al.~\cite{xu_efficient_2019} proposed an efficient scheme based on double-masking which is a fault-tolerance perturbation-based protocol.
% While 单服务器
When under the single cloud server setting, workers have to participate the iterations, so that workers need to suffer additional computing and communication overhead.

To reduce workers' overhead, Miao et al.~\cite{miao_lightweight_2017} proposed $L$-PPTD and $L^2$-PPTD by involving two non-colluding cloud servers.
% Different from the single cloud server setting, workers 
After that, more and more schemes are designed under two non-colluding cloud servers setting (such as~\cite{zhang_lptd_2019,zhang_reliable_2019,xue_inpptd_2020,tang_achieving_2021}).

On the other hand, most of the existing privacy-preserving truth discovery schemes are based on CRH algorithm, which requires workers to provide sensory data for all objects.
But in the real-world mobile crowdsensing systems (like sparse mobile crowd sensing~\cite{wang_sparse_2016}), it is usually impractical for workers to observe all objects at a specific moment.
The issue of data sparsity in mobile crowdsensing is getting more and more attention from recent years, especially when taking privacy preservation into account.
% According to research~\cite{wang_sparse_2020}, it is important not only to protect the sensory data observed by workers, but also to protect what objects observed by workers.
% There are two types of privacy need to protect, one is the data observed by workers, the other is which objects observed by workers.
Fortunately, there is another truth discovery algorithm called CATD~\cite{li_confidence-aware_2014} for handling long-tail data, which is also suitable for the sparse data situation.
% In comparison, CATD~\cite{li_confidence-aware_2014} is another truth discovery algorithm for handling long-tail data, which is also suitable for the sparse data situation.
Zheng et al.~\cite{zheng_learning_2018} designed an encrypted truth discovery based on CATD under two non-colluding cloud servers where all procedures are conducted in the encrypted domain.
However, according to research~\cite{wang_sparse_2020}, it is important not only to protect the sensory data observed by workers, but also to protect what objects observed by workers.
% As depicted in Figure xxx, 
% And the existing privacy-preserving scheme based on CATD~\cite{zheng_learning_2018} 
% But the existing privacy-preserving scheme based on CATD~\cite{zheng_learning_2018} only considered the privacy of sensory data 
There still lacks research on the two types of privayc for truth discovery in sparse crowd sensing.

\section{System Model and Design Goals}\label{sec3}

In this section, we present the system model and formulate the problem we target in this paper.
% sparse data problem in MCS.
\subsection{System Model}\label{sec3-A}

Generally, our system model consists of two types of entities: a number of workers and two cloud servers. %用图说明
The specific explanations of these entities are listed as follows.
% worker 的作用， cloud server 的作用
\begin{itemize}
  \item \textbf{Workers:} Workers refers to the data providers with mobile devices (e.g., smartphones, wearables) in MCS. They are responsible for collecting sensory data of different objects. After that, these sensory data are uploaded to two cloud servers.  Since most of mobile devices are resource-limited, it is not necessary for each worker to collect sensory data of all objects.
  \item \textbf{Clouds:} Clouds are responsible for analysing the sensory data of different objects. More specifically, after receiving the uploaded sensory data, these two cloud servers start to estimate the ground truth for each sensory object. We assume that the two cloud servers have sufficient computation and storage capabilities.
  % the agency to analyse the 
\end{itemize}
% Workers are responsible for collecting sensory data of different objects.
% After that, workers need to upload their sensory data to two cloud servers.
In this paper, suppose that there are $M$ objects need to be collected, and the number of workers is $K$.
We denote $x_m^k$ as the sensory data of object $m$ of worker $k$.
Moreover, worker $k$ also maintains an indication vector $\Phi_k = \{\phi_1^k, \ldots, \phi_M^k\}$ to mark the missing sensory objects in which $\phi_m^k = 1$ means worker $k$ has collected the sensory data of object $m$, and $\phi_m^k = 0$ otherwise.
Each worker uploads the sensory data and task vector to clouds.
After that, two cloud servers calculate each worker's weight (denoted by $w_k$ for worker $k$), and finally estimate the ground truth for each object (denoted by $x_m^*$ for object $m$). 
% The goal of two cloud servers is to estimate the ground truth $X^* = \{x_1^*, x_2^*, \ldots, x_M^*\}$ for each sensory object, where $x_m^*$ represents the estimated ground truth for $m$-th object.
\subsection{Threat Model and Design Goals}

In our proposed scheme, we assume that all entities are semi-honest, which means that no matter workers or coulds will honestly execute the protocols, but they are also curious about participants' privacy, such as workers' sensory data, worker's weights.
Moreover, the two cloud servers in our scheme are non-colluding, which is a common assumption in most two-server models~\cite{zhang_lptd_2019,zhang_reliable_2019}.
% 不考虑 恶意 workers， 不考虑 lazy workers
Note that the lazy workers are not considered, since this issue can be solved by integrating incentive mechanism~\cite{xue_inpptd_2020}.
% The consideration of malicious workers are also not involved, 
% \section{Problem Statement}
% In this section, we describe the truth discovery and formulate the sparse data problem in crowd sensing systems.

The main purpose of our shceme is to protect workers' privacy.
Since the sensory data providered by workers are sparse, we should not only consider the privacy of sensory data, but also consider the privacy of indication vectors.

% there are two kind of privacy need to be considered.
% The first one is the 
% of workers while the 
% workers' privacy while they 
% protecting workers' privacy 
% The design goals of our proposed scheme can be 

% \subsection{Background on Truth Discovery}

% In real-world crowdsensing applications, truth discovery is 
% Weight Update:

% $$w_k = \frac{\chi_{(1-\alpha/2, \sum_{m=1}^M \phi_m^k)}^2}{\sum_M (x_m^k - x_m^*)^2}$$

% Truth Update:

% $$x_m^* = \frac{\sum_K w_k \phi_m^k x_m^k }{\sum_K \phi_m^k x_m^k}$$

% \subsection{System Model}


\section{Preliminaries}\label{sec4}

In this section, we introduce the truth discovery algorithm CATD~\cite{li_confidence-aware_2014} and additively homomorphic cryptosystem.
% ABY2.0~\cite{patra_aby20_2020}.

% \subsection{Homomorphic Encryption}

\subsection{CATD}

% CATD 强调与 worker 提交的数量，。。。
In general, truth discovery algorithm consists of two parts: weight update and truth update.

\textit{1) Weight Update:} Given the ground truth, the weight for each worker $k$ is computed as
\begin{equation}
w_k = \frac{\chi^2_{(1-\alpha/2,\sum_{m=1}^M \phi_m^k)}}{\sum_{m=1}^M \phi_m^k(x_m^k - x_m^*)^2}
\end{equation}
Note that $\chi^2$ denotes the Chi-squared distribution, and the constant $\alpha$ denotes the significant level which is usually a small number such as 0.05.

\textit{2) Truth Update:} Given the weight $w_k$ for each worker $k$, the truth for each object $m$ is computed as
\begin{equation}
x_m^* = \frac{\sum_{k=1}^K w_k x_m^k}{\sum_{k=1}^K \phi_m^k w_k }
\end{equation}

In real applications, to achieve more accurate ground truth values, weight update and truth update should be executed iteratively until the convergence criteria is met.

\subsection{Additively Homomorphic Cryptosystem}\label{sec4-b}

We adopt additive homomorphic cryptosystem in our proposed scheme.
Generally, an additive homomorphic cryptosystem consists of the following probabilistic poly-time algorithms.

\begin{itemize}
  \item $\mathsf{Setup}(1^\kappa)\to pp$: Taken the input of security parameter $\kappa$, the algorithm returns the public parameter $pp$.
  \item $\mathsf{KeyGen}(1^\kappa)\to (pk, sk)$: Taken the input of security parameter $\kappa$, the algorithm returns the public key $pk$ and private key $sk$.
  \item $\mathsf{Enc}_{pk}(m)\to c$: Given the message $m$, the encryption algorithm outputs $c$ which is the ciphertext of message $m$.
  \item $\mathsf{Dec}_{sk}(c)\to m$: Given the ciphertext $c$, the decryption algorithm outputs the corresponding plaintext $m$.
\end{itemize}

We called that above public-key cryptosystem is additively homomorphic if it satisfies the following properties.

\begin{itemize}
  \item Given two ciphertexts $c_1 = \mathsf{Enc}_{pk}(m_1)$ and $c_2 = \mathsf{Enc}_{pk}(m_2)$, it holds that $\mathsf{Dec}_{sk}(c_1 \cdot c_2) = m_1 + m_2$.
  \item Given a constant $a$ and a ciphertext $c=\mathsf{Enc}_{pk}(m)$, it holds that $\mathsf{Dec}_{sk}(c^a) = a\cdot m$.
\end{itemize}

\subsection{Secret Sharing}

To be complete


\iffalse
\subsection{ABY2.0}

% for secure two-party computation,
ABY2.0 is an efficient mixed-protocol framework which allows two parties to jointly evaluate a function based on their private inputs~\cite{patra_aby20_2020}.
In this paper, we make use of arithmetic sharing and multiplication protocol of ABY2.0 as the building blocks.
Specificly, we use $\{S_0, S_1\}$ to denote the two parties, and all protocols are executed over an $\ell$-bit ring denoted by $\mathbb{Z}_{2^\ell}$.
For a value $v\in\mathbb{Z}_{2^\ell}$, there are two sharing semantics in ABY2.0, as denoted by $[\cdot]$-sharing and $\langle \cdot \rangle$-sharing as follows.

\textit{$[\cdot]$-sharing:} A value $v\in\mathbb{Z}_{2^\ell}$ is said to be $[\cdot]$-sharing among $\{S_0, S_1\}$, which means the party $S_i$ for $i\in\{0,1\}$ holds $[v]_i$ such that $v = [v]_0 + [v]_1$.

\textit{$\langle \cdot \rangle$-sharing:} A value $v\in\mathbb{Z}_{2^\ell}$ is said to be $\langle \cdot \rangle$-sharing among $\{S_0, S_1\}$, which means the party $S_i$ for $i\in\{0,1\}$ holds $\langle v \rangle_i = (\Delta_v, [\delta_v]_i)$, where $\Delta_v = v + \delta_v$.

It is clear that both $[\cdot]$-sharing and $\langle \cdot \rangle$-sharing supoort linear operations.
For example, given the $\langle \cdot \rangle$-sharing of $a,b$ and public constants $c_1,c_2$, $S_i$ can locally compute $\langle y_i \rangle = c_1 \cdot \langle a \rangle_i + c_2 \cdot \langle b \rangle_i$.
But the multiplication protocol is non-trivial, we give a brief describtion at a high level.
For more detail, please refer to~\cite{patra_aby20_2020}.

The multiplication protocol enables two parties to generate $\langle y \rangle$ where $y = ab$ when given the $\langle \cdot \rangle$-sharing of $a,b$.
\fi

% Specifically, we 

\section{The Proposed Scheme}\label{sec5}

In this section, we describe the proposed scheme in detail.

\subsection{Overview}

% 设计目标场景
As we mentioned above, our privacy-preserving truth discovery scheme is designed for scenarios where the sensory data provided by workers are sparse.
In the proposed scheme, workers need to upload indication vectors to mark which objects they observed.
Therefore, it is a challenge to protect the privacy of indication vectors, sensory data and workers' weight at the same time.
Although applying GC is a straightforward method to achieve strong privacy preservation, the generation of GC is still a cumbersome task.
% 包含

To protect workers' privacy and make the procedure efficient, we design a novel protocol by adopting additively homomorphic cryptosystem.
The whole procedure can be divided into three phases: {\em Initialization Phase}, {\em Sensing Phase}, {\em Iteration Phase}.
% At a high level, 

\subsection{Initialization Phase}

As described in Section~\ref{sec3-A}, assume that there are $K$ participating workers and $M$ sensing objects in the system.
In this phase, $S_0$ first generates an asymmetric key pair $(pk, sk)$ of the additively homomorphic cryptosystem by invoking $\mathsf{KeyGen}(\cdot)$ in Section~\ref{sec4-b}.
Then $S_0$ sets a small number for the significant level $\alpha$ ($\alpha$ is set to 0.05 by default), and publishes the public key $pk$ and significant level $\alpha$.

% the public key $pk$ and private $sk$ by invoking $\mathsf{KeyGen}(\cdot)$ described in Section~\ref{sec4-b}.

\subsection{Upload Phase}

In this phase, each worker collects sensory data for distinct objects.
Taking worker $k$ as an example, after obtaining a set of sensory data $\{x_m^k\}_{m=1}^M$ and an indication vector $\{\phi_m^k\}_{m=1}^M$, worker $k$ computes $y_k = \chi^2_{(1-\alpha/2, \sum_{m=1}^M \phi_m^k)}$.
Then for each object $m$, worker $k$ computes $\tilde{\phi}_m^k = \phi_m^k / y_k$.
Finally, worker $k$ computes additive shares of $x_m^k$ and $\tilde{\phi}_m^k$ respectively, i.e., $x_m^k = x_{m,0}^k + x_{m,1}^k$, $\tilde{\phi}_m^k = \tilde{\phi}_{m,0}^k + \tilde{\phi}_{m,1}^k$, and uploads $\{x_{m,0}^k, \tilde{\phi}_{m,0}^k\}_{m=1}^M$ to $S_0$, uploads $\{x_{m,1}^k, \tilde{\phi}_{m,1}^k\}_{m=1}^M$ to $S_1$.
When the upload process is complete, worker $k$ can go offline.
% 有的 worker 不想做全部的任务 （放到 introduction 部分）
% After that, each worker obtains a set of sensory data and an indication vector

\subsection{Secure Weight Update Phase}

In this phase, each worker's weight is estimated based on the ground truth and uploaded data.
Note that if this phase is executed for the first time, we choose the ground truth randomly.
For worker $k$, $S_0$ first computes $C_0^k$ as: 
\begin{equation}
  \begin{split}
  C_0^k = \mathsf{Enc}_{pk}(\sum_{m=1}^M [\tilde{\phi}_{m,0}^k\cdot (x_{m,0}^k)^2])
  \end{split}
\end{equation}
Then $S_0$ encrypts $\{x_{m,0}^k, (x_{m,0}^k)^2, \tilde{\phi}_{m,0}^k,\tilde{\phi}_{m,0}^k\cdot x_{m,0}^k\}_{m,k=1}^{M,K}$ respectively.
These ciphertexts are typically denoted by $C_{pack1}$.
Finally, $S_0$ sends $\{C_0^k, C_{pack1}^k\}_{k=1}^K$ to $S_1$.
% We denote $C_{pack}$ as the set of ciphertexts.
% To give a clear illustration, we denote $C_{pack} = \{\mathsf{E}_{pk}(x_{m,0}^k), \mathsf{E}_{pk}((x_{m,0}^k)^2), \mathsf{E}_{pk}(\tilde{\phi}_{m,0}^k), \mathsf{E}_{pk}(\tilde{\phi}_{m,0}^k x_{m,0}^k)\}_{m=1}^M$.
 % $$\{\mathsf{E}_{pk}(x_{m,0}^k), \mathsf{E}_{pk}((x_{m,0}^k)^2), \mathsf{E}_{pk}(\tilde{\phi}_{m,0}^k), \mathsf{E}_{pk}(\tilde{\phi}_{m,0}^k x_{m,0}^k)\}_{m=1}^M$$ to $S_1$.

Upon receiving the ciphertexts, $S_1$ computes $C_1^k$,$C_2^k$,$C_3^k$,$C_4^k$ as follows.
\begin{equation}
  \begin{split}
  C_1^k = &\prod_{m=1}^M\left[ \mathsf{Enc}_{pk}{[(x_{m,0}^k)^2]}^{\tilde{\phi}_{m,1}^k} \right]
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
  C_2^k = & \prod_{m=1}^M\left[ \left[\mathsf{Enc}_{pk}\left(x_{m,0}^k\right)\right]^{2(x_{m,1}^k - x_m^*)\tilde{\phi}_{m,1}^k}\right] \cdot \\
          & \prod_{m=1}^M\left[ \left[\mathsf{Enc}_{pk}\left(\tilde{\phi}_{m,0}^k x_{m,0}^k\right)\right]^{2(x_{m,1}^k - x_m^*)} \right] \\
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    C_3^k & = \prod_{m=1}^M\left[ \mathsf{Enc}_{pk}(\tilde{\phi}_{m,0}^k)^{(x_{m,1}^k - x_m^*)^2} \right]
    % & = \mathsf{Enc}_{pk}(\sum_{m=1}^M \tilde{\phi}_{m,0}^k \cdot (x_{m,1}^k - x_m^*)^2)
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    C_4^k & = \mathsf{Enc}_{pk}(\sum_{m=1}^M \tilde{\phi}_{m,1}^k \cdot (x_{m,1}^k - x_m^*)^2)
  \end{split}
\end{equation}
Then $S_1$ choose a random value $b_k$ and computes the ciphertexts $C_k$ as 
\begin{equation}
  \begin{split}
    C_k = \left(C_0^k\cdot C_1^k\cdot C_2^k\cdot C_3^k \cdot C_4^k\right)^{b_k}
  \end{split}
\end{equation}
Finally $S_1$ sends $\{C_k\}_{k=1}^K$ to $S_0$.
After receiving $\{C_k\}_{k=1}^K$, $S_0$ first decryptes $C_k$ with its private key and obtains the perturbed weight $\tilde{w}_k$ of worker $k$ as follows,
\begin{equation}
  \begin{split}
    \tilde{w}_k = \frac{1}{\mathsf{Dec}_{sk}(C_k)} = \frac{y_k}{b_k\cdot \sum_{m=1}^M \phi_m^k(x_m^k - x_m^*)^2} = \frac{w_k}{b_k}
  \end{split}
\end{equation}

% \begin{equation}
  % \begin{split}
    % \mathsf{Enc}_{pk}(1/w_k) & = C_0 \cdot C_1 \cdot C_2 \cdot C_3 \cdot C_4 \\
    % & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_m^k\cdot (x_{m,0}^k)^2 + 2\cdot\tilde{\phi}_m^k x_{m,0}^k (x_{m,1}^k-x_m^*) + \tilde{\phi}_m^k (x_{m,1}^k - x_m^*)^2 \right] \\
    % & = \mathsf{Enc}_{pk}\left[\sum_{m=1}^M \tilde{\phi}_m^k (x_m^k - x_m^*)^2 \right] \\
    % & = \mathsf{Enc}_{pk}\left[\frac{\sum_{m=1}^M \phi_m^k (x_m^k - x_m^*)^2}{y} \right] \\
  % \end{split}
% \end{equation}

\subsection{Secure Truth Update Phase}

In the weight update phase, $S_0$ obtains the perturbed weight $\tilde{w}_k$ for each worker $k$.
To estimate the ground truth for each object, $S_0$ first encrypts $\{\tilde{w}_k, \tilde{w}_k\cdot x_{m,0}^k, \tilde{w}_k\cdot \phi_{m,0}^k\}_{m,k=1}^{M,K}$.
We denote the set of ciphertexts as $C_{pack2}$.
Finally $S_0$ sends $C_{pack2}$ to $S_1$.

After receiving the ciphertexts, $S_1$ computes $C_5^m$ and $C_6^m$ as follows,
\begin{equation}
  \begin{split}
    C_5^m = \prod_{k=1}^K\left[\left[\mathsf{Enc}_{pk}(\tilde{w}_k\cdot x_{m,0}^k)\cdot \left[\mathsf{Enc}_{pk}(\tilde{w}_k)\right]^{x_{m,0}^k}\right]^{b_k} \right]
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    C_6^m = \prod_{k=1}^K \left[ \left[ \mathsf{Enc}_{pk}(\tilde{w}_k\cdot \phi_{m,0}^k) \cdot \left[\mathsf{Enc}_{pk}(\tilde{w}_k)\right]^{\phi_{m,1}^k}\right]^{b_k} \right]
    % C_6^m = \prod_{k=1}^K \left[ \letf[\mathsf{Enc}_{pk}(\tilde{w}_k\cdot \phi_{m,0}^k)\right]^{b_k} \cdot \mathsf{Enc}_{pk}()\right]
  \end{split}
\end{equation}
% Then $S_0$ encrypts $\{\tilde{w}_k\}_{k=1}^K$, we denotes the set of ciphertexts by $C_{pack2}^k$.
% Finally $S_0$ sends $\{C_5^m, C_6^m\}_{m=1}^M$ and $\{C_{pack2}^k\}_{k=1}^K$ to $S_1$.
% After receiving the ciphertexts, $S_1$ computes $C_7^m$ and $C_8^m$ as follows,
% \begin{equation}
  % \begin{split}
    % C_7^m = \mathsf{Enc}_{pk}(\tilde{w}_k)
  % \end{split}
% \end{equation}
Finally $S_1$ sends $\{C_5^m\}_{m=1}^M$ and $\{C_6^m\}_{m=1}^M$ to $S_0$.
Then $S_0$ decrypts these ciphertexts and obtains the groud truth as follows,
\begin{equation}
  \begin{split}
    x_m^* = \frac{\mathsf{Dec}_{sk}(C_5^m)}{\mathsf{Dec}_{sk}(C_6^m)}
  \end{split}
\end{equation}

\section{Performance Evaluation}\label{sec5}
\section{Conclusion}\label{sec6}

\bibliographystyle{IEEEtran}
\bibliography{ref}

\vspace{12pt}

\end{document}